/*
* MATLAB Compiler: 4.16 (R2011b)
* Date: Fri Feb 10 20:47:06 2012
* Arguments: "-B" "macro_default" "-W" "dotnet:mPhys,Class1,0.0,private" "-T" "link:lib"
* "-d" "d:\Synapse System\Matlab Scope for NET oneFolder\mFiles\mPhys\src" "-N" "-p"
* "curvefit" "-p" "signal" "-p" "stats" "-w" "enable:specified_file_mismatch" "-w"
* "enable:repeated_file" "-w" "enable:switch_ignored" "-w" "enable:missing_lib_sentinel"
* "-w" "enable:demo_license" "-v" "class{Class1:D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addFunctionToPlot.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addStatusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\analysisAxis.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apHeight.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apRiseFallRatio.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apThreshold.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apWidth.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apWidthHM.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\autoCorrelate.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\autoNotch.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\bandStop.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benConv.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benDisplayString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benEventsOld.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenFitLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenFitPolynomial.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benGenerateStim.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benPeakAllPoints.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benPeakAllPointsTenths.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benProtocolViewer.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benStats1Array.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benStats2Arrays.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenVectorMedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenWrapPolyFit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenWrapSGolayFilt.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\besselFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\blankAPsWithConstant.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\blankAPsWithNaNs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\burstingProbability.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcBurstProb.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcMean.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcSTA.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcSTO.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\cell2mat.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\characterizePSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\clearBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\clearExtraLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\colorSpread.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\combFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\commonEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\Contents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\crossCorr.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\crosscorrelateSetup.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectAPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectPSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectPSPs3d.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectSpikes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\displayEventLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\displayEventLinesSimple.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\dumpPreferences.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\evaluateBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\evaluateExportText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\eventTriggeredAverage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\executeMatlabLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportToRDrive.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportWithAxes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportWithScaleBars.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fastAHP.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fastAHPSlope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fcnMin.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\findSteps.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\findStims.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit1Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit2Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit3Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitAlpha.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitBoltzmann.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitBoltzmannBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecayDouble.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecaySingle.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecayTriple.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitLineExtra.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitSine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fourier.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\generateStim.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\GetFromMatlab.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\getScopeVersion.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\getVoltTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\highPass.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\histfit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\intervalHist.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\isiCv.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\isiCvEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\jointDist.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\LorenPowerSpectrum.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\lowPass.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeBesselFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeButterFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeCheby1Filter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeCheby2Filter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeEllipFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLines2.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLinesTest.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\Matlab Setup Listener.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlot.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlotNoJitter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlotOld.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MatlabSetupListener.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\meanVariance.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\medianFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\metaBar.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\metaCorrEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLdiff.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLmedfilt1.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLpolyfit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLpolyval.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLsgolayfilt.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\movingAverage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\movingBlock.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\msec2point.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MTEO.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MTEOBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\newScale.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\newScope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\normalizeMatrix.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\notchFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\oneSidedDeviation.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\overlayPSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotAverageFreq.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotFreq.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotHistogram.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotPercentCorrelation.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\prepForPrint.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\printWithAxes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\printWithScaleBars.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBenNewStyle.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBenOld2.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readVBString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\refreshAllScopes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\removeTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\replaceTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\restartSystem.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\runGeneralFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile2Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile3Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile3VectorsUnique.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile4Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sec2time.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendFilenamesToScope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendFilenamesToScopeNoRefresh.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendMessage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SendToMatlab.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\setAxisLabels.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sfigure.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SGfilterBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showFFT.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showFrameMarker.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showStims.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\startInterprocess.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testDrawLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testMessage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testMessageString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\timeControl.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\VBmedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\VBmovingMedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\wakeUp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\whichChannel.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\whiteNoiseFile.m}" 
*/
using System;
using System.Reflection;
using System.IO;
using MathWorks.MATLAB.NET.Arrays;
using MathWorks.MATLAB.NET.Utility;

#if SHARED
[assembly: System.Reflection.AssemblyKeyFile(@"")]
#endif

namespace mPhysNative
{

  /// <summary>
  /// The Class1 class provides a CLS compliant, Object (native) interface to the
  /// M-functions contained in the files:
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addFunctionToPlot.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addStatusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\analysisAxis.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apHeight.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apRiseFallRatio.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apThreshold.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apWidth.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apWidthHM.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\autoCorrelate.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\autoNotch.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\bandStop.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benConv.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benDisplayString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benEventsOld.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenFitLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenFitPolynomial.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benGenerateStim.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benPeakAllPoints.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benPeakAllPointsTenths.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benProtocolViewer.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benStats1Array.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benStats2Arrays.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenVectorMedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenWrapPolyFit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenWrapSGolayFilt.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\besselFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\blankAPsWithConstant.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\blankAPsWithNaNs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\burstingProbability.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcBurstProb.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcMean.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcSTA.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcSTO.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\cell2mat.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\characterizePSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\clearBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\clearExtraLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\colorSpread.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\combFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\commonEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\Contents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\crossCorr.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\crosscorrelateSetup.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectAPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectPSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectPSPs3d.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectSpikes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\displayEventLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\displayEventLinesSimple.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\dumpPreferences.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\evaluateBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\evaluateExportText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\eventTriggeredAverage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\executeMatlabLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportToRDrive.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportWithAxes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportWithScaleBars.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fastAHP.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fastAHPSlope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fcnMin.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\findSteps.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\findStims.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit1Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit2Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit3Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitAlpha.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitBoltzmann.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitBoltzmannBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecayDouble.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecaySingle.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecayTriple.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitLineExtra.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitSine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fourier.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\generateStim.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\GetFromMatlab.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\getScopeVersion.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\getVoltTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\highPass.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\histfit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\intervalHist.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\isiCv.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\isiCvEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\jointDist.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\LorenPowerSpectrum.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\lowPass.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeBesselFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeButterFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeCheby1Filter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeCheby2Filter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeEllipFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLines2.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLinesTest.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\Matlab Setup Listener.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlot.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlotNoJitter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlotOld.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MatlabSetupListener.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\meanVariance.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\medianFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\metaBar.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\metaCorrEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLdiff.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLmedfilt1.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLpolyfit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLpolyval.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLsgolayfilt.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\movingAverage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\movingBlock.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\msec2point.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MTEO.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MTEOBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\newScale.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\newScope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\normalizeMatrix.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\notchFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\oneSidedDeviation.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\overlayPSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotAverageFreq.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotFreq.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotHistogram.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotPercentCorrelation.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\prepForPrint.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\printWithAxes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\printWithScaleBars.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBenNewStyle.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBenOld2.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readVBString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\refreshAllScopes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\removeTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\replaceTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\restartSystem.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\runGeneralFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile2Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile3Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET
  /// oneFolder\mFiles\SaveAsMatFile3VectorsUnique.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile4Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sec2time.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendFilenamesToScope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET
  /// oneFolder\mFiles\sendFilenamesToScopeNoRefresh.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendMessage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SendToMatlab.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\setAxisLabels.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sfigure.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SGfilterBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showFFT.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showFrameMarker.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showStims.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\startInterprocess.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testDrawLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testMessage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testMessageString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\timeControl.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\VBmedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\VBmovingMedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\wakeUp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\whichChannel.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\whiteNoiseFile.m
  /// <newpara></newpara>
  /// deployprint.m
  /// <newpara></newpara>
  /// printdlg.m
  /// </summary>
  /// <remarks>
  /// @Version 0.0
  /// </remarks>
  public class Class1 : IDisposable
  {
    #region Constructors

    /// <summary internal= "true">
    /// The static constructor instantiates and initializes the MATLAB Compiler Runtime
    /// instance.
    /// </summary>
    static Class1()
    {
      if (MWMCR.MCRAppInitialized)
      {
        Assembly assembly= Assembly.GetExecutingAssembly();

        string ctfFilePath= assembly.Location;

        int lastDelimiter= ctfFilePath.LastIndexOf(@"\");

        ctfFilePath= ctfFilePath.Remove(lastDelimiter, (ctfFilePath.Length - lastDelimiter));

        string ctfFileName = "mPhys.ctf";

        Stream embeddedCtfStream = null;

        String[] resourceStrings = assembly.GetManifestResourceNames();

        foreach (String name in resourceStrings)
        {
          if (name.Contains(ctfFileName))
          {
            embeddedCtfStream = assembly.GetManifestResourceStream(name);
            break;
          }
        }
        mcr= new MWMCR("",
                       ctfFilePath, embeddedCtfStream, true);
      }
      else
      {
        throw new ApplicationException("MWArray assembly could not be initialized");
      }
    }


    /// <summary>
    /// Constructs a new instance of the Class1 class.
    /// </summary>
    public Class1()
    {
    }


    #endregion Constructors

    #region Finalize

    /// <summary internal= "true">
    /// Class destructor called by the CLR garbage collector.
    /// </summary>
    ~Class1()
    {
      Dispose(false);
    }


    /// <summary>
    /// Frees the native resources associated with this object
    /// </summary>
    public void Dispose()
    {
      Dispose(true);

      GC.SuppressFinalize(this);
    }


    /// <summary internal= "true">
    /// Internal dispose function
    /// </summary>
    protected virtual void Dispose(bool disposing)
    {
      if (!disposed)
      {
        disposed= true;

        if (disposing)
        {
          // Free managed resources;
        }

        // Free native resources
      }
    }


    #endregion Finalize

    #region Methods

    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void addBonusText()
    {
      mcr.EvaluateFunction(0, "addBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    ///
    public void addBonusText(Object text)
    {
      mcr.EvaluateFunction(0, "addBonusText", text);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    ///
    public void addBonusText(Object text, Object figHandle)
    {
      mcr.EvaluateFunction(0, "addBonusText", text, figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addBonusText(int numArgsOut, Object text)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", text);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addBonusText(int numArgsOut, Object text, Object figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", text, figHandle);
    }


    /// <summary>
    /// Provides an interface for the addBonusText function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("addBonusText", 2, 0, 0)]
    protected void addBonusText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("addBonusText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void addFunctionToPlot()
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void addFunctionToPlot(Object traceName)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    ///
    public void addFunctionToPlot(Object traceName, Object xData)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    ///
    public void addFunctionToPlot(Object traceName, Object xData, Object yData)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData);
    }


    /// <summary>
    /// Provides a void output, 4-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    ///
    public void addFunctionToPlot(Object traceName, Object xData, Object yData, Object 
                            colorName)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName);
    }


    /// <summary>
    /// Provides a void output, 5-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    ///
    public void addFunctionToPlot(Object traceName, Object xData, Object yData, Object 
                            colorName, Object lineWidth)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth);
    }


    /// <summary>
    /// Provides a void output, 6-input Objectinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <param name="lineStyle">Input argument #6</param>
    ///
    public void addFunctionToPlot(Object traceName, Object xData, Object yData, Object 
                            colorName, Object lineWidth, Object lineStyle)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth, lineStyle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName, Object xData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName, Object xData, 
                                Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName, Object xData, 
                                Object yData, Object colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName, Object xData, 
                                Object yData, Object colorName, Object lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 6-input Object interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <param name="lineStyle">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addFunctionToPlot(int numArgsOut, Object traceName, Object xData, 
                                Object yData, Object colorName, Object lineWidth, Object 
                                lineStyle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth, lineStyle);
    }


    /// <summary>
    /// Provides an interface for the addFunctionToPlot function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("addFunctionToPlot", 6, 0, 0)]
    protected void addFunctionToPlot(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("addFunctionToPlot", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void addStatusText()
    {
      mcr.EvaluateFunction(0, "addStatusText", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    ///
    public void addStatusText(Object text)
    {
      mcr.EvaluateFunction(0, "addStatusText", text);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    ///
    public void addStatusText(Object text, Object figHandle)
    {
      mcr.EvaluateFunction(0, "addStatusText", text, figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addStatusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addStatusText(int numArgsOut, Object text)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", text);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addStatusText(int numArgsOut, Object text, Object figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", text, figHandle);
    }


    /// <summary>
    /// Provides an interface for the addStatusText function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("addStatusText", 2, 0, 0)]
    protected void addStatusText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("addStatusText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object addTrace()
    {
      return mcr.EvaluateFunction("addTrace", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object addTrace(Object newData)
    {
      return mcr.EvaluateFunction("addTrace", newData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object addTrace(Object newData, Object channelName)
    {
      return mcr.EvaluateFunction("addTrace", newData, channelName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addTrace(int numArgsOut, Object newData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", newData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] addTrace(int numArgsOut, Object newData, Object channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", newData, channelName);
    }


    /// <summary>
    /// Provides an interface for the addTrace function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("addTrace", 2, 1, 0)]
    protected void addTrace(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("addTrace", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object analysisAxis()
    {
      return mcr.EvaluateFunction("analysisAxis", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="plotName">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object analysisAxis(Object plotName)
    {
      return mcr.EvaluateFunction("analysisAxis", plotName);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="plotName">Input argument #1</param>
    /// <param name="axisHandle_in1">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object analysisAxis(Object plotName, Object axisHandle_in1)
    {
      return mcr.EvaluateFunction("analysisAxis", plotName, axisHandle_in1);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] analysisAxis(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="plotName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] analysisAxis(int numArgsOut, Object plotName)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", plotName);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="plotName">Input argument #1</param>
    /// <param name="axisHandle_in1">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] analysisAxis(int numArgsOut, Object plotName, Object axisHandle_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", plotName, axisHandle_in1);
    }


    /// <summary>
    /// Provides an interface for the analysisAxis function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("analysisAxis", 2, 1, 0)]
    protected void analysisAxis(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("analysisAxis", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apHeight()
    {
      return mcr.EvaluateFunction("apHeight", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apHeight(Object inData)
    {
      return mcr.EvaluateFunction("apHeight", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apHeight(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apHeight(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apHeight(Object inData, Object timePerPoint, Object startTime, Object 
                     axisHandle)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apHeight(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apHeight(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apHeight(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apHeight(int numArgsOut, Object inData, Object timePerPoint, Object 
                       startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apHeight(int numArgsOut, Object inData, Object timePerPoint, Object 
                       startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apHeight function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("apHeight", 4, 1, 0)]
    protected void apHeight(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("apHeight", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apRiseFallRatio()
    {
      return mcr.EvaluateFunction("apRiseFallRatio", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apRiseFallRatio(Object traceData)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apRiseFallRatio(Object traceData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apRiseFallRatio(Object traceData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apRiseFallRatio(Object traceData, Object timePerPoint, Object 
                            startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the apRiseFallRatio M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apRiseFallRatio(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the apRiseFallRatio M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apRiseFallRatio(int numArgsOut, Object traceData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the apRiseFallRatio M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apRiseFallRatio(int numArgsOut, Object traceData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the apRiseFallRatio M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apRiseFallRatio(int numArgsOut, Object traceData, Object 
                              timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the apRiseFallRatio M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apRiseFallRatio(int numArgsOut, Object traceData, Object 
                              timePerPoint, Object startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apRiseFallRatio function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("apRiseFallRatio", 4, 1, 0)]
    protected void apRiseFallRatio(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("apRiseFallRatio", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apThreshold()
    {
      return mcr.EvaluateFunction("apThreshold", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apThreshold(Object inData)
    {
      return mcr.EvaluateFunction("apThreshold", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apThreshold(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apThreshold(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apThreshold(Object inData, Object timePerPoint, Object startTime, 
                        Object axisHandle)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apThreshold(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apThreshold(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apThreshold(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apThreshold(int numArgsOut, Object inData, Object timePerPoint, 
                          Object startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apThreshold(int numArgsOut, Object inData, Object timePerPoint, 
                          Object startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apThreshold function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("apThreshold", 4, 1, 0)]
    protected void apThreshold(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("apThreshold", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidth()
    {
      return mcr.EvaluateFunction("apWidth", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidth(Object traceData)
    {
      return mcr.EvaluateFunction("apWidth", traceData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidth(Object traceData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidth(Object traceData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidth(Object traceData, Object timePerPoint, Object startTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidth(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidth(int numArgsOut, Object traceData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidth(int numArgsOut, Object traceData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidth(int numArgsOut, Object traceData, Object timePerPoint, Object 
                      startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidth(int numArgsOut, Object traceData, Object timePerPoint, Object 
                      startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apWidth function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("apWidth", 4, 1, 0)]
    protected void apWidth(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("apWidth", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidthHM()
    {
      return mcr.EvaluateFunction("apWidthHM", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidthHM(Object inData)
    {
      return mcr.EvaluateFunction("apWidthHM", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidthHM(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidthHM(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object apWidthHM(Object inData, Object timePerPoint, Object startTime, Object 
                      axisHandle)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidthHM(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidthHM(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidthHM(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidthHM(int numArgsOut, Object inData, Object timePerPoint, Object 
                        startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] apWidthHM(int numArgsOut, Object inData, Object timePerPoint, Object 
                        startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apWidthHM function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("apWidthHM", 4, 1, 0)]
    protected void apWidthHM(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("apWidthHM", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the autoCorrelate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoCorrelate()
    {
      return mcr.EvaluateFunction("autoCorrelate", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the autoCorrelate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoCorrelate(params Object[] varargin)
    {
      return mcr.EvaluateFunction("autoCorrelate", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the autoCorrelate M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoCorrelate(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoCorrelate", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the autoCorrelate M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoCorrelate(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoCorrelate", varargin);
    }


    /// <summary>
    /// Provides an interface for the autoCorrelate function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("autoCorrelate", 0, 1, 1)]
    protected void autoCorrelate(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("autoCorrelate", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoNotch()
    {
      return mcr.EvaluateFunction("autoNotch", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoNotch(Object inData)
    {
      return mcr.EvaluateFunction("autoNotch", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoNotch(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoNotch(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object autoNotch(Object inData, Object timePerPoint, Object startTime, Object 
                      axisHandle)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoNotch(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoNotch(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoNotch(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoNotch(int numArgsOut, Object inData, Object timePerPoint, Object 
                        startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] autoNotch(int numArgsOut, Object inData, Object timePerPoint, Object 
                        startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the autoNotch function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("autoNotch", 4, 1, 0)]
    protected void autoNotch(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("autoNotch", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object bandStop()
    {
      return mcr.EvaluateFunction("bandStop", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object bandStop(Object inData)
    {
      return mcr.EvaluateFunction("bandStop", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object bandStop(Object inData, Object lowStopBand)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object bandStop(Object inData, Object lowStopBand, Object highStopBand)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand, highStopBand);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <param name="samplingFreq">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object bandStop(Object inData, Object lowStopBand, Object highStopBand, Object 
                     samplingFreq)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand, highStopBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] bandStop(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] bandStop(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] bandStop(int numArgsOut, Object inData, Object lowStopBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] bandStop(int numArgsOut, Object inData, Object lowStopBand, Object 
                       highStopBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand, highStopBand);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <param name="samplingFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] bandStop(int numArgsOut, Object inData, Object lowStopBand, Object 
                       highStopBand, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand, highStopBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the bandStop function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("bandStop", 4, 1, 0)]
    protected void bandStop(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("bandStop", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benConv()
    {
      return mcr.EvaluateFunction("benConv", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="inTrace">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benConv(Object inTrace)
    {
      return mcr.EvaluateFunction("benConv", inTrace);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="inTrace">Input argument #1</param>
    /// <param name="kernel">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benConv(Object inTrace, Object kernel)
    {
      return mcr.EvaluateFunction("benConv", inTrace, kernel);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benConv(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inTrace">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benConv(int numArgsOut, Object inTrace)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", inTrace);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inTrace">Input argument #1</param>
    /// <param name="kernel">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benConv(int numArgsOut, Object inTrace, Object kernel)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", inTrace, kernel);
    }


    /// <summary>
    /// Provides an interface for the benConv function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benConv", 2, 1, 0)]
    protected void benConv(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benConv", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benDisplayString()
    {
      return mcr.EvaluateFunction("benDisplayString", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="inNum">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benDisplayString(Object inNum)
    {
      return mcr.EvaluateFunction("benDisplayString", inNum);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benDisplayString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benDisplayString", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inNum">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benDisplayString(int numArgsOut, Object inNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "benDisplayString", inNum);
    }


    /// <summary>
    /// Provides an interface for the benDisplayString function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benDisplayString", 1, 1, 0)]
    protected void benDisplayString(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benDisplayString", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents()
    {
      return mcr.EvaluateFunction("benEvents", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData)
    {
      return mcr.EvaluateFunction("benEvents", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData, Object downEvents)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData, Object downEvents, Object MsPerPoint)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData, Object downEvents, Object MsPerPoint, Object 
                      startTime)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData, Object downEvents, Object MsPerPoint, Object 
                      startTime, Object endTime)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides a single output, 6-input Objectinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEvents(Object inData, Object downEvents, Object MsPerPoint, Object 
                      startTime, Object endTime, Object parmList)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData, Object downEvents)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData, Object downEvents, Object 
                        MsPerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData, Object downEvents, Object 
                        MsPerPoint, Object startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData, Object downEvents, Object 
                        MsPerPoint, Object startTime, Object endTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides the standard 6-input Object interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEvents(int numArgsOut, Object inData, Object downEvents, Object 
                        MsPerPoint, Object startTime, Object endTime, Object parmList)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides an interface for the benEvents function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benEvents", 6, 1, 0)]
    protected void benEvents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benEvents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld()
    {
      return mcr.EvaluateFunction("benEventsOld", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data)
    {
      return mcr.EvaluateFunction("benEventsOld", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data, Object downEvents)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data, Object downEvents, Object MsPerPoint)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data, Object downEvents, Object MsPerPoint, Object 
                         startTime)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data, Object downEvents, Object MsPerPoint, Object 
                         startTime, Object endTime)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides a single output, 6-input Objectinterface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benEventsOld(Object data, Object downEvents, Object MsPerPoint, Object 
                         startTime, Object endTime, Object parmList)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data, Object downEvents)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data, Object downEvents, Object 
                           MsPerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data, Object downEvents, Object 
                           MsPerPoint, Object startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data, Object downEvents, Object 
                           MsPerPoint, Object startTime, Object endTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides the standard 6-input Object interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benEventsOld(int numArgsOut, Object data, Object downEvents, Object 
                           MsPerPoint, Object startTime, Object endTime, Object parmList)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides an interface for the benEventsOld function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benEventsOld", 6, 1, 0)]
    protected void benEventsOld(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benEventsOld", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitLine()
    {
      return mcr.EvaluateFunction("BenFitLine", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitLine(Object yData)
    {
      return mcr.EvaluateFunction("BenFitLine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitLine(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("BenFitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitLine(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitLine(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides an interface for the BenFitLine function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("BenFitLine", 2, 1, 0)]
    protected void BenFitLine(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("BenFitLine", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitPolynomial()
    {
      return mcr.EvaluateFunction("BenFitPolynomial", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitPolynomial(Object yData)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitPolynomial(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenFitPolynomial(Object yData, Object timePerPoint, Object PolyOrder)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitPolynomial(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitPolynomial(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitPolynomial(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenFitPolynomial(int numArgsOut, Object yData, Object timePerPoint, 
                               Object PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides an interface for the BenFitPolynomial function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("BenFitPolynomial", 3, 1, 0)]
    protected void BenFitPolynomial(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("BenFitPolynomial", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benGenerateStim()
    {
      return mcr.EvaluateFunction("benGenerateStim", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benGenerateStim(Object zData)
    {
      return mcr.EvaluateFunction("benGenerateStim", zData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <param name="chanNum">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benGenerateStim(Object zData, Object chanNum)
    {
      return mcr.EvaluateFunction("benGenerateStim", zData, chanNum);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benGenerateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benGenerateStim(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benGenerateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benGenerateStim(int numArgsOut, Object zData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", zData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benGenerateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <param name="chanNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benGenerateStim(int numArgsOut, Object zData, Object chanNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", zData, chanNum);
    }


    /// <summary>
    /// Provides an interface for the benGenerateStim function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benGenerateStim", 2, 1, 0)]
    protected void benGenerateStim(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benGenerateStim", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benPeakAllPoints()
    {
      return mcr.EvaluateFunction("benPeakAllPoints", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benPeakAllPoints(Object inData)
    {
      return mcr.EvaluateFunction("benPeakAllPoints", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benPeakAllPoints(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPoints", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benPeakAllPoints(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPoints", inData);
    }


    /// <summary>
    /// Provides an interface for the benPeakAllPoints function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benPeakAllPoints", 1, 1, 0)]
    protected void benPeakAllPoints(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benPeakAllPoints", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benPeakAllPointsTenths()
    {
      return mcr.EvaluateFunction("benPeakAllPointsTenths", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benPeakAllPointsTenths(Object inData)
    {
      return mcr.EvaluateFunction("benPeakAllPointsTenths", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benPeakAllPointsTenths(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPointsTenths", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benPeakAllPointsTenths(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPointsTenths", inData);
    }


    /// <summary>
    /// Provides an interface for the benPeakAllPointsTenths function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benPeakAllPointsTenths", 1, 1, 0)]
    protected void benPeakAllPointsTenths(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benPeakAllPointsTenths", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    ///
    public void benProtocolViewer()
    {
      mcr.EvaluateFunction(0, "benProtocolViewer", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="fileName">Input argument #1</param>
    ///
    public void benProtocolViewer(Object fileName)
    {
      mcr.EvaluateFunction(0, "benProtocolViewer", fileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benProtocolViewer(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benProtocolViewer", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="fileName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benProtocolViewer(int numArgsOut, Object fileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "benProtocolViewer", fileName);
    }


    /// <summary>
    /// Provides an interface for the benProtocolViewer function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benProtocolViewer", 1, 0, 0)]
    protected void benProtocolViewer(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benProtocolViewer", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats1Array()
    {
      return mcr.EvaluateFunction("benStats1Array", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats1Array(Object inArray1)
    {
      return mcr.EvaluateFunction("benStats1Array", inArray1);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="testValue">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats1Array(Object inArray1, Object testValue)
    {
      return mcr.EvaluateFunction("benStats1Array", inArray1, testValue);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats1Array(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats1Array(int numArgsOut, Object inArray1)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", inArray1);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="testValue">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats1Array(int numArgsOut, Object inArray1, Object testValue)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", inArray1, testValue);
    }


    /// <summary>
    /// Provides an interface for the benStats1Array function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benStats1Array", 2, 3, 0)]
    protected void benStats1Array(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benStats1Array", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats2Arrays()
    {
      return mcr.EvaluateFunction("benStats2Arrays", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats2Arrays(Object inArray1)
    {
      return mcr.EvaluateFunction("benStats2Arrays", inArray1);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object benStats2Arrays(Object inArray1, Object inArray2)
    {
      return mcr.EvaluateFunction("benStats2Arrays", inArray1, inArray2);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the benStats2Arrays M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats2Arrays(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the benStats2Arrays M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats2Arrays(int numArgsOut, Object inArray1)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", inArray1);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the benStats2Arrays M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] benStats2Arrays(int numArgsOut, Object inArray1, Object inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", inArray1, inArray2);
    }


    /// <summary>
    /// Provides an interface for the benStats2Arrays function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("benStats2Arrays", 2, 5, 0)]
    protected void benStats2Arrays(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("benStats2Arrays", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenVectorMedian()
    {
      return mcr.EvaluateFunction("BenVectorMedian", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenVectorMedian(Object inArray)
    {
      return mcr.EvaluateFunction("BenVectorMedian", inArray);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the BenVectorMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenVectorMedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenVectorMedian", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the BenVectorMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenVectorMedian(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenVectorMedian", inArray);
    }


    /// <summary>
    /// Provides an interface for the BenVectorMedian function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("BenVectorMedian", 1, 1, 0)]
    protected void BenVectorMedian(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("BenVectorMedian", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapPolyFit()
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapPolyFit(Object yData)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapPolyFit(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapPolyFit(Object yData, Object timePerPoint, Object PolyOrder)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapPolyFit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapPolyFit(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapPolyFit(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapPolyFit(int numArgsOut, Object yData, Object timePerPoint, 
                             Object PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides an interface for the BenWrapPolyFit function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("BenWrapPolyFit", 3, 1, 0)]
    protected void BenWrapPolyFit(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("BenWrapPolyFit", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapSGolayFilt()
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapSGolayFilt(Object InVector)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapSGolayFilt(Object InVector, Object PolyOrder)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object BenWrapSGolayFilt(Object InVector, Object PolyOrder, Object FrameSize)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapSGolayFilt(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapSGolayFilt(int numArgsOut, Object InVector)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapSGolayFilt(int numArgsOut, Object InVector, Object PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] BenWrapSGolayFilt(int numArgsOut, Object InVector, Object PolyOrder, 
                                Object FrameSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides an interface for the BenWrapSGolayFilt function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("BenWrapSGolayFilt", 3, 1, 0)]
    protected void BenWrapSGolayFilt(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("BenWrapSGolayFilt", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object besselFilter()
    {
      return mcr.EvaluateFunction("besselFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object besselFilter(Object inData)
    {
      return mcr.EvaluateFunction("besselFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object besselFilter(Object inData, Object samplingFreq)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object besselFilter(Object inData, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <param name="cutOff">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object besselFilter(Object inData, Object samplingFreq, Object order, Object 
                         cutOff)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq, order, cutOff);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] besselFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] besselFilter(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] besselFilter(int numArgsOut, Object inData, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] besselFilter(int numArgsOut, Object inData, Object samplingFreq, 
                           Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <param name="cutOff">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] besselFilter(int numArgsOut, Object inData, Object samplingFreq, 
                           Object order, Object cutOff)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq, order, cutOff);
    }


    /// <summary>
    /// Provides an interface for the besselFilter function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("besselFilter", 4, 1, 0)]
    protected void besselFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("besselFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithConstant()
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithConstant(Object inData)
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithConstant(Object inData, Object thresh)
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", inData, thresh);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithConstant(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithConstant(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithConstant(int numArgsOut, Object inData, Object thresh)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", inData, thresh);
    }


    /// <summary>
    /// Provides an interface for the blankAPsWithConstant function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("blankAPsWithConstant", 2, 1, 0)]
    protected void blankAPsWithConstant(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("blankAPsWithConstant", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithNaNs()
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithNaNs(Object inData)
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object blankAPsWithNaNs(Object inData, Object thresh)
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", inData, thresh);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithNaNs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithNaNs(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] blankAPsWithNaNs(int numArgsOut, Object inData, Object thresh)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", inData, thresh);
    }


    /// <summary>
    /// Provides an interface for the blankAPsWithNaNs function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("blankAPsWithNaNs", 2, 1, 0)]
    protected void blankAPsWithNaNs(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("blankAPsWithNaNs", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object burstingProbability()
    {
      return mcr.EvaluateFunction("burstingProbability", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object burstingProbability(Object inData)
    {
      return mcr.EvaluateFunction("burstingProbability", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object burstingProbability(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("burstingProbability", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="threshTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object burstingProbability(Object inData, Object timePerPoint, Object 
                                threshTime)
    {
      return mcr.EvaluateFunction("burstingProbability", inData, timePerPoint, threshTime);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] burstingProbability(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] burstingProbability(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] burstingProbability(int numArgsOut, Object inData, Object 
                                  timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="threshTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] burstingProbability(int numArgsOut, Object inData, Object 
                                  timePerPoint, Object threshTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData, timePerPoint, threshTime);
    }


    /// <summary>
    /// Provides an interface for the burstingProbability function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("burstingProbability", 3, 2, 0)]
    protected void burstingProbability(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("burstingProbability", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the calcBurstProb
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcBurstProb()
    {
      return mcr.EvaluateFunction("calcBurstProb", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the calcBurstProb
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcBurstProb(params Object[] varargin)
    {
      return mcr.EvaluateFunction("calcBurstProb", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the calcBurstProb M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcBurstProb(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcBurstProb", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the calcBurstProb M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcBurstProb(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcBurstProb", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcBurstProb function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("calcBurstProb", 0, 1, 1)]
    protected void calcBurstProb(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("calcBurstProb", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcMean()
    {
      return mcr.EvaluateFunction("calcMean", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcMean(Object inData)
    {
      return mcr.EvaluateFunction("calcMean", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcMean(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcMean", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcMean(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcMean", inData);
    }


    /// <summary>
    /// Provides an interface for the calcMean function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("calcMean", 1, 1, 0)]
    protected void calcMean(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("calcMean", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcSTA()
    {
      return mcr.EvaluateFunction("calcSTA", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcSTA(params Object[] varargin)
    {
      return mcr.EvaluateFunction("calcSTA", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcSTA(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTA", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcSTA(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTA", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcSTA function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("calcSTA", 0, 1, 1)]
    protected void calcSTA(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("calcSTA", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcSTO()
    {
      return mcr.EvaluateFunction("calcSTO", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object calcSTO(params Object[] varargin)
    {
      return mcr.EvaluateFunction("calcSTO", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcSTO(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTO", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] calcSTO(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTO", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcSTO function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("calcSTO", 0, 1, 1)]
    protected void calcSTO(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("calcSTO", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object cell2mat()
    {
      return mcr.EvaluateFunction("cell2mat", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="c">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object cell2mat(Object c)
    {
      return mcr.EvaluateFunction("cell2mat", c);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] cell2mat(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "cell2mat", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="c">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] cell2mat(int numArgsOut, Object c)
    {
      return mcr.EvaluateFunction(numArgsOut, "cell2mat", c);
    }


    /// <summary>
    /// Provides an interface for the cell2mat function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("cell2mat", 1, 1, 0)]
    protected void cell2mat(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("cell2mat", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object characterizePSPs()
    {
      return mcr.EvaluateFunction("characterizePSPs", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="PSPs">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object characterizePSPs(Object PSPs)
    {
      return mcr.EvaluateFunction("characterizePSPs", PSPs);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="PSPs">Input argument #1</param>
    /// <param name="totalTime">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object characterizePSPs(Object PSPs, Object totalTime)
    {
      return mcr.EvaluateFunction("characterizePSPs", PSPs, totalTime);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] characterizePSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="PSPs">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] characterizePSPs(int numArgsOut, Object PSPs)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", PSPs);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="PSPs">Input argument #1</param>
    /// <param name="totalTime">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] characterizePSPs(int numArgsOut, Object PSPs, Object totalTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", PSPs, totalTime);
    }


    /// <summary>
    /// Provides an interface for the characterizePSPs function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("characterizePSPs", 2, 1, 0)]
    protected void characterizePSPs(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("characterizePSPs", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void clearBonusText()
    {
      mcr.EvaluateFunction(0, "clearBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    ///
    public void clearBonusText(Object figHandle)
    {
      mcr.EvaluateFunction(0, "clearBonusText", figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] clearBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] clearBonusText(int numArgsOut, Object figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearBonusText", figHandle);
    }


    /// <summary>
    /// Provides an interface for the clearBonusText function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("clearBonusText", 1, 0, 0)]
    protected void clearBonusText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("clearBonusText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the clearExtraLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void clearExtraLines()
    {
      mcr.EvaluateFunction(0, "clearExtraLines", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the clearExtraLines M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] clearExtraLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearExtraLines", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the clearExtraLines function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("clearExtraLines", 0, 0, 0)]
    protected void clearExtraLines(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("clearExtraLines", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object colorSpread()
    {
      return mcr.EvaluateFunction("colorSpread", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object colorSpread(Object m)
    {
      return mcr.EvaluateFunction("colorSpread", m);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] colorSpread(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "colorSpread", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] colorSpread(int numArgsOut, Object m)
    {
      return mcr.EvaluateFunction(numArgsOut, "colorSpread", m);
    }


    /// <summary>
    /// Provides an interface for the colorSpread function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("colorSpread", 1, 1, 0)]
    protected void colorSpread(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("colorSpread", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object combFilter()
    {
      return mcr.EvaluateFunction("combFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object combFilter(Object inData)
    {
      return mcr.EvaluateFunction("combFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object combFilter(Object inData, Object selectedFrequencies)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object combFilter(Object inData, Object selectedFrequencies, Object 
                       samplingFreq)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <param name="whichPart">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object combFilter(Object inData, Object selectedFrequencies, Object 
                       samplingFreq, Object whichPart)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies, samplingFreq, whichPart);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] combFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] combFilter(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] combFilter(int numArgsOut, Object inData, Object selectedFrequencies)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] combFilter(int numArgsOut, Object inData, Object selectedFrequencies, 
                         Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <param name="whichPart">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] combFilter(int numArgsOut, Object inData, Object selectedFrequencies, 
                         Object samplingFreq, Object whichPart)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies, samplingFreq, whichPart);
    }


    /// <summary>
    /// Provides an interface for the combFilter function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("combFilter", 4, 1, 0)]
    protected void combFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("combFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object commonEvents()
    {
      return mcr.EvaluateFunction("commonEvents", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object commonEvents(params Object[] varargin)
    {
      return mcr.EvaluateFunction("commonEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] commonEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "commonEvents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] commonEvents(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "commonEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the commonEvents function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("commonEvents", 0, 1, 1)]
    protected void commonEvents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("commonEvents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the Contents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void Contents()
    {
      mcr.EvaluateFunction(0, "Contents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the Contents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] Contents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "Contents", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the Contents function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("Contents", 0, 0, 0)]
    protected void Contents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("Contents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crossCorr()
    {
      return mcr.EvaluateFunction("crossCorr", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crossCorr(Object data)
    {
      return mcr.EvaluateFunction("crossCorr", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crossCorr(Object data, Object corrVals)
    {
      return mcr.EvaluateFunction("crossCorr", data, corrVals);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <param name="coincidenceInterval">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crossCorr(Object data, Object corrVals, Object coincidenceInterval)
    {
      return mcr.EvaluateFunction("crossCorr", data, corrVals, coincidenceInterval);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crossCorr(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crossCorr(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crossCorr(int numArgsOut, Object data, Object corrVals)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data, corrVals);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <param name="coincidenceInterval">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crossCorr(int numArgsOut, Object data, Object corrVals, Object 
                        coincidenceInterval)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data, corrVals, coincidenceInterval);
    }


    /// <summary>
    /// Provides an interface for the crossCorr function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("crossCorr", 3, 3, 0)]
    protected void crossCorr(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("crossCorr", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crosscorrelateSetup()
    {
      return mcr.EvaluateFunction("crosscorrelateSetup", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object crosscorrelateSetup(params Object[] varargin)
    {
      return mcr.EvaluateFunction("crosscorrelateSetup", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crosscorrelateSetup(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "crosscorrelateSetup", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] crosscorrelateSetup(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "crosscorrelateSetup", varargin);
    }


    /// <summary>
    /// Provides an interface for the crosscorrelateSetup function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("crosscorrelateSetup", 0, 1, 1)]
    protected void crosscorrelateSetup(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("crosscorrelateSetup", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectAPs()
    {
      return mcr.EvaluateFunction("detectAPs", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectAPs(Object data)
    {
      return mcr.EvaluateFunction("detectAPs", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectAPs(Object data, Object protocol)
    {
      return mcr.EvaluateFunction("detectAPs", data, protocol);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <param name="varargin">Array of Objects representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectAPs(Object data, Object protocol, params Object[] varargin)
    {
      Object[] argsIn= {data, protocol, varargin};

      return mcr.EvaluateFunction("detectAPs", argsIn);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectAPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectAPs(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectAPs(int numArgsOut, Object data, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", data, protocol);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <param name="varargin">Array of Objects representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectAPs(int numArgsOut, Object data, Object protocol, params 
                        Object[] varargin)
    {
      Object[] argsIn= {data, protocol, varargin};

      return mcr.EvaluateFunction(numArgsOut, "detectAPs", argsIn);
    }


    /// <summary>
    /// Provides an interface for the detectAPs function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("detectAPs", 2, 1, 1)]
    protected void detectAPs(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("detectAPs", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs()
    {
      return mcr.EvaluateFunction("detectPSPs", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs(Object data)
    {
      return mcr.EvaluateFunction("detectPSPs", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs(Object data, params Object[] varargin)
    {
      Object[] argsIn= {data, varargin};

      return mcr.EvaluateFunction("detectPSPs", argsIn);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs(int numArgsOut, Object data, params Object[] varargin)
    {
      Object[] argsIn= {data, varargin};

      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", argsIn);
    }


    /// <summary>
    /// Provides an interface for the detectPSPs function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("detectPSPs", 1, 2, 1)]
    protected void detectPSPs(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("detectPSPs", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs3d()
    {
      return mcr.EvaluateFunction("detectPSPs3d", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs3d(Object data)
    {
      return mcr.EvaluateFunction("detectPSPs3d", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectPSPs3d(Object data, Object protocol)
    {
      return mcr.EvaluateFunction("detectPSPs3d", data, protocol);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs3d(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs3d(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectPSPs3d(int numArgsOut, Object data, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", data, protocol);
    }


    /// <summary>
    /// Provides an interface for the detectPSPs3d function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("detectPSPs3d", 2, 2, 0)]
    protected void detectPSPs3d(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("detectPSPs3d", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectSpikes()
    {
      return mcr.EvaluateFunction("detectSpikes", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectSpikes(Object inData)
    {
      return mcr.EvaluateFunction("detectSpikes", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectSpikes(Object inData, Object spikeHeight)
    {
      return mcr.EvaluateFunction("detectSpikes", inData, spikeHeight);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <param name="whereCall">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object detectSpikes(Object inData, Object spikeHeight, Object whereCall)
    {
      return mcr.EvaluateFunction("detectSpikes", inData, spikeHeight, whereCall);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectSpikes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectSpikes(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectSpikes(int numArgsOut, Object inData, Object spikeHeight)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData, spikeHeight);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <param name="whereCall">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] detectSpikes(int numArgsOut, Object inData, Object spikeHeight, 
                           Object whereCall)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData, spikeHeight, whereCall);
    }


    /// <summary>
    /// Provides an interface for the detectSpikes function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("detectSpikes", 3, 1, 0)]
    protected void detectSpikes(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("detectSpikes", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void displayEventLines()
    {
      mcr.EvaluateFunction(0, "displayEventLines", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    ///
    public void displayEventLines(Object channelName)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    ///
    public void displayEventLines(Object channelName, Object baselineValue)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    ///
    public void displayEventLines(Object channelName, Object baselineValue, Object 
                            eventTimes)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes);
    }


    /// <summary>
    /// Provides a void output, 4-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    ///
    public void displayEventLines(Object channelName, Object baselineValue, Object 
                            eventTimes, Object eventAmps)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps);
    }


    /// <summary>
    /// Provides a void output, 5-input Objectinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <param name="eventColors">Input argument #5</param>
    ///
    public void displayEventLines(Object channelName, Object baselineValue, Object 
                            eventTimes, Object eventAmps, Object eventColors)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps, eventColors);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut, Object channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut, Object channelName, Object 
                                baselineValue)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut, Object channelName, Object 
                                baselineValue, Object eventTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut, Object channelName, Object 
                                baselineValue, Object eventTimes, Object eventAmps)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <param name="eventColors">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLines(int numArgsOut, Object channelName, Object 
                                baselineValue, Object eventTimes, Object eventAmps, 
                                Object eventColors)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps, eventColors);
    }


    /// <summary>
    /// Provides an interface for the displayEventLines function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("displayEventLines", 5, 0, 0)]
    protected void displayEventLines(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("displayEventLines", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object displayEventLinesSimple()
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object displayEventLinesSimple(Object eventTimes)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object displayEventLinesSimple(Object eventTimes, Object lineMin)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes, lineMin);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <param name="lineMax">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object displayEventLinesSimple(Object eventTimes, Object lineMin, Object 
                                    lineMax)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes, lineMin, lineMax);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLinesSimple(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLinesSimple(int numArgsOut, Object eventTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLinesSimple(int numArgsOut, Object eventTimes, Object 
                                      lineMin)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes, lineMin);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <param name="lineMax">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] displayEventLinesSimple(int numArgsOut, Object eventTimes, Object 
                                      lineMin, Object lineMax)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes, lineMin, lineMax);
    }


    /// <summary>
    /// Provides an interface for the displayEventLinesSimple function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("displayEventLinesSimple", 3, 1, 0)]
    protected void displayEventLinesSimple(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("displayEventLinesSimple", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the dumpPreferences
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void dumpPreferences()
    {
      mcr.EvaluateFunction(0, "dumpPreferences", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the dumpPreferences M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] dumpPreferences(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "dumpPreferences", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the dumpPreferences function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("dumpPreferences", 0, 0, 0)]
    protected void dumpPreferences(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("dumpPreferences", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object evaluateBonusText()
    {
      return mcr.EvaluateFunction("evaluateBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object evaluateBonusText(Object protocol)
    {
      return mcr.EvaluateFunction("evaluateBonusText", protocol);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] evaluateBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateBonusText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] evaluateBonusText(int numArgsOut, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateBonusText", protocol);
    }


    /// <summary>
    /// Provides an interface for the evaluateBonusText function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("evaluateBonusText", 1, 1, 0)]
    protected void evaluateBonusText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("evaluateBonusText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the evaluateExportText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object evaluateExportText()
    {
      return mcr.EvaluateFunction("evaluateExportText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the evaluateExportText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] evaluateExportText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateExportText", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the evaluateExportText function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("evaluateExportText", 0, 1, 0)]
    protected void evaluateExportText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("evaluateExportText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage()
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage(Object events)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage(Object events, Object postTrace)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage(Object events, Object postTrace, Object window)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage(Object events, Object postTrace, Object window, 
                                  Object timePerPoint)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <param name="showAllTraces">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object eventTriggeredAverage(Object events, Object postTrace, Object window, 
                                  Object timePerPoint, Object showAllTraces)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window, timePerPoint, showAllTraces);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut, Object events)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut, Object events, Object postTrace)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut, Object events, Object 
                                    postTrace, Object window)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut, Object events, Object 
                                    postTrace, Object window, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <param name="showAllTraces">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] eventTriggeredAverage(int numArgsOut, Object events, Object 
                                    postTrace, Object window, Object timePerPoint, Object 
                                    showAllTraces)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window, timePerPoint, showAllTraces);
    }


    /// <summary>
    /// Provides an interface for the eventTriggeredAverage function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("eventTriggeredAverage", 5, 1, 0)]
    protected void eventTriggeredAverage(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("eventTriggeredAverage", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object executeMatlabLine()
    {
      return mcr.EvaluateFunction("executeMatlabLine", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object executeMatlabLine(Object inString)
    {
      return mcr.EvaluateFunction("executeMatlabLine", inString);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] executeMatlabLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "executeMatlabLine", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] executeMatlabLine(int numArgsOut, Object inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "executeMatlabLine", inString);
    }


    /// <summary>
    /// Provides an interface for the executeMatlabLine function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("executeMatlabLine", 1, 1, 0)]
    protected void executeMatlabLine(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("executeMatlabLine", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportToRDrive()
    {
      mcr.EvaluateFunction(0, "exportToRDrive", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportToRDrive(Object figure)
    {
      mcr.EvaluateFunction(0, "exportToRDrive", figure);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportToRDrive(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportToRDrive", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportToRDrive(int numArgsOut, Object figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportToRDrive", figure);
    }


    /// <summary>
    /// Provides an interface for the exportToRDrive function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("exportToRDrive", 1, 0, 0)]
    protected void exportToRDrive(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("exportToRDrive", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportWithAxes()
    {
      mcr.EvaluateFunction(0, "exportWithAxes", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportWithAxes(Object figure)
    {
      mcr.EvaluateFunction(0, "exportWithAxes", figure);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportWithAxes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithAxes", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportWithAxes(int numArgsOut, Object figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithAxes", figure);
    }


    /// <summary>
    /// Provides an interface for the exportWithAxes function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("exportWithAxes", 1, 0, 0)]
    protected void exportWithAxes(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("exportWithAxes", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportWithScaleBars()
    {
      mcr.EvaluateFunction(0, "exportWithScaleBars", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportWithScaleBars(Object figure)
    {
      mcr.EvaluateFunction(0, "exportWithScaleBars", figure);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportWithScaleBars(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithScaleBars", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] exportWithScaleBars(int numArgsOut, Object figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithScaleBars", figure);
    }


    /// <summary>
    /// Provides an interface for the exportWithScaleBars function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("exportWithScaleBars", 1, 0, 0)]
    protected void exportWithScaleBars(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("exportWithScaleBars", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHP()
    {
      return mcr.EvaluateFunction("fastAHP", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHP(Object inData)
    {
      return mcr.EvaluateFunction("fastAHP", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHP(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHP(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHP(Object inData, Object timePerPoint, Object startTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHP(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHP(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHP(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHP(int numArgsOut, Object inData, Object timePerPoint, Object 
                      startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHP(int numArgsOut, Object inData, Object timePerPoint, Object 
                      startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fastAHP function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fastAHP", 4, 2, 0)]
    protected void fastAHP(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fastAHP", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHPSlope()
    {
      return mcr.EvaluateFunction("fastAHPSlope", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHPSlope(Object inData)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHPSlope(Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHPSlope(Object inData, Object timePerPoint, Object startTime)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fastAHPSlope(Object inData, Object timePerPoint, Object startTime, 
                         Object axisHandle)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHPSlope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHPSlope(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHPSlope(int numArgsOut, Object inData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHPSlope(int numArgsOut, Object inData, Object timePerPoint, 
                           Object startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fastAHPSlope(int numArgsOut, Object inData, Object timePerPoint, 
                           Object startTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fastAHPSlope function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fastAHPSlope", 4, 1, 0)]
    protected void fastAHPSlope(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fastAHPSlope", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fcnMin()
    {
      return mcr.EvaluateFunction("fcnMin", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fcnMin(Object inData)
    {
      return mcr.EvaluateFunction("fcnMin", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fcnMin(Object inData, Object number)
    {
      return mcr.EvaluateFunction("fcnMin", inData, number);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <param name="type">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fcnMin(Object inData, Object number, Object type)
    {
      return mcr.EvaluateFunction("fcnMin", inData, number, type);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fcnMin(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fcnMin(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fcnMin(int numArgsOut, Object inData, Object number)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData, number);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <param name="type">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fcnMin(int numArgsOut, Object inData, Object number, Object type)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData, number, type);
    }


    /// <summary>
    /// Provides an interface for the fcnMin function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fcnMin", 3, 1, 0)]
    protected void fcnMin(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fcnMin", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findSteps()
    {
      return mcr.EvaluateFunction("findSteps", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findSteps(Object protocol)
    {
      return mcr.EvaluateFunction("findSteps", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findSteps(Object protocol, Object ampNum)
    {
      return mcr.EvaluateFunction("findSteps", protocol, ampNum);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findSteps(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findSteps(int numArgsOut, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findSteps(int numArgsOut, Object protocol, Object ampNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", protocol, ampNum);
    }


    /// <summary>
    /// Provides an interface for the findSteps function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("findSteps", 2, 3, 0)]
    protected void findSteps(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("findSteps", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findStims()
    {
      return mcr.EvaluateFunction("findStims", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findStims(Object protocol)
    {
      return mcr.EvaluateFunction("findStims", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="isIndex">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object findStims(Object protocol, Object isIndex)
    {
      return mcr.EvaluateFunction("findStims", protocol, isIndex);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findStims(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findStims(int numArgsOut, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="isIndex">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] findStims(int numArgsOut, Object protocol, Object isIndex)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", protocol, isIndex);
    }


    /// <summary>
    /// Provides an interface for the findStims function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("findStims", 2, 1, 0)]
    protected void findStims(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("findStims", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit1Exp()
    {
      return mcr.EvaluateFunction("fit1Exp", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit1Exp(Object yData)
    {
      return mcr.EvaluateFunction("fit1Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit1Exp(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit1Exp(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit1Exp(Object yData, Object timePerPoint, Object startingTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit1Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit1Exp(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit1Exp(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit1Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit1Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit1Exp function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fit1Exp", 4, 1, 0)]
    protected void fit1Exp(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fit1Exp", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit2Exp()
    {
      return mcr.EvaluateFunction("fit2Exp", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit2Exp(Object yData)
    {
      return mcr.EvaluateFunction("fit2Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit2Exp(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit2Exp(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit2Exp(Object yData, Object timePerPoint, Object startingTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit2Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit2Exp(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit2Exp(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit2Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit2Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit2Exp function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fit2Exp", 4, 1, 0)]
    protected void fit2Exp(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fit2Exp", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit3Exp()
    {
      return mcr.EvaluateFunction("fit3Exp", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit3Exp(Object yData)
    {
      return mcr.EvaluateFunction("fit3Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit3Exp(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit3Exp(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fit3Exp(Object yData, Object timePerPoint, Object startingTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit3Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit3Exp(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit3Exp(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit3Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fit3Exp(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit3Exp function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fit3Exp", 4, 1, 0)]
    protected void fit3Exp(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fit3Exp", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitAlpha()
    {
      return mcr.EvaluateFunction("fitAlpha", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitAlpha(Object yData)
    {
      return mcr.EvaluateFunction("fitAlpha", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitAlpha(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitAlpha(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitAlpha(Object yData, Object timePerPoint, Object startingTime, Object 
                     axisHandle)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitAlpha(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitAlpha(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitAlpha(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitAlpha(int numArgsOut, Object yData, Object timePerPoint, Object 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitAlpha(int numArgsOut, Object yData, Object timePerPoint, Object 
                       startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitAlpha function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitAlpha", 4, 1, 0)]
    protected void fitAlpha(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitAlpha", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann()
    {
      return mcr.EvaluateFunction("fitBoltzmann", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann(Object yData)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann(Object yData, Object timePerPoint, Object startingTime, 
                         Object axisHandle)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmann(Object yData, Object timePerPoint, Object startingTime, 
                         Object axisHandle, Object traceName)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut, Object yData, Object timePerPoint, 
                           Object startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut, Object yData, Object timePerPoint, 
                           Object startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmann(int numArgsOut, Object yData, Object timePerPoint, 
                           Object startingTime, Object axisHandle, Object traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides an interface for the fitBoltzmann function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitBoltzmann", 5, 1, 0)]
    protected void fitBoltzmann(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitBoltzmann", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen()
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen(Object yData)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen(Object yData, Object timePerPoint, Object startingTime, 
                            Object axisHandle)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitBoltzmannBen(Object yData, Object timePerPoint, Object startingTime, 
                            Object axisHandle, Object traceName)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut, Object yData, Object timePerPoint, 
                              Object startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut, Object yData, Object timePerPoint, 
                              Object startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the fitBoltzmannBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitBoltzmannBen(int numArgsOut, Object yData, Object timePerPoint, 
                              Object startingTime, Object axisHandle, Object traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides an interface for the fitBoltzmannBen function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitBoltzmannBen", 5, 1, 0)]
    protected void fitBoltzmannBen(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitBoltzmannBen", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayDouble()
    {
      return mcr.EvaluateFunction("fitDecayDouble", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayDouble(Object yData)
    {
      return mcr.EvaluateFunction("fitDecayDouble", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayDouble(Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction("fitDecayDouble", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayDouble(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayDouble(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayDouble(int numArgsOut, Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecayDouble function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitDecayDouble", 2, 4, 0)]
    protected void fitDecayDouble(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitDecayDouble", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecaySingle()
    {
      return mcr.EvaluateFunction("fitDecaySingle", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecaySingle(Object yData)
    {
      return mcr.EvaluateFunction("fitDecaySingle", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecaySingle(Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction("fitDecaySingle", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecaySingle(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecaySingle(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecaySingle(int numArgsOut, Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecaySingle function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitDecaySingle", 2, 4, 0)]
    protected void fitDecaySingle(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitDecaySingle", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayTriple()
    {
      return mcr.EvaluateFunction("fitDecayTriple", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayTriple(Object yData)
    {
      return mcr.EvaluateFunction("fitDecayTriple", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitDecayTriple(Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction("fitDecayTriple", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayTriple(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayTriple(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitDecayTriple(int numArgsOut, Object yData, Object PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecayTriple function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitDecayTriple", 2, 5, 0)]
    protected void fitDecayTriple(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitDecayTriple", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLine()
    {
      return mcr.EvaluateFunction("fitLine", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLine(Object yData)
    {
      return mcr.EvaluateFunction("fitLine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLine(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLine(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLine(Object yData, Object timePerPoint, Object startingTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLine(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLine(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLine(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLine(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitLine function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitLine", 4, 1, 0)]
    protected void fitLine(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitLine", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLineExtra()
    {
      return mcr.EvaluateFunction("fitLineExtra", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLineExtra(Object yData)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLineExtra(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLineExtra(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitLineExtra(Object yData, Object timePerPoint, Object startingTime, 
                         Object axisHandle)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLineExtra(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLineExtra(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLineExtra(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLineExtra(int numArgsOut, Object yData, Object timePerPoint, 
                           Object startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitLineExtra(int numArgsOut, Object yData, Object timePerPoint, 
                           Object startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitLineExtra function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitLineExtra", 4, 1, 0)]
    protected void fitLineExtra(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitLineExtra", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitSine()
    {
      return mcr.EvaluateFunction("fitSine", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitSine(Object yData)
    {
      return mcr.EvaluateFunction("fitSine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitSine(Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitSine(Object yData, Object timePerPoint, Object startingTime)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fitSine(Object yData, Object timePerPoint, Object startingTime, Object 
                    axisHandle)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitSine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitSine(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitSine(int numArgsOut, Object yData, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitSine(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fitSine(int numArgsOut, Object yData, Object timePerPoint, Object 
                      startingTime, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitSine function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fitSine", 4, 1, 0)]
    protected void fitSine(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fitSine", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fourier()
    {
      return mcr.EvaluateFunction("fourier", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fourier(Object yData)
    {
      return mcr.EvaluateFunction("fourier", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fourier(Object yData, Object fs)
    {
      return mcr.EvaluateFunction("fourier", yData, fs);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <param name="frequencies">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object fourier(Object yData, Object fs, Object frequencies)
    {
      return mcr.EvaluateFunction("fourier", yData, fs, frequencies);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fourier(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fourier(int numArgsOut, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fourier(int numArgsOut, Object yData, Object fs)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData, fs);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <param name="frequencies">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] fourier(int numArgsOut, Object yData, Object fs, Object frequencies)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData, fs, frequencies);
    }


    /// <summary>
    /// Provides an interface for the fourier function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("fourier", 3, 2, 0)]
    protected void fourier(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("fourier", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object generateStim()
    {
      return mcr.EvaluateFunction("generateStim", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="protocolData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object generateStim(Object protocolData)
    {
      return mcr.EvaluateFunction("generateStim", protocolData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="protocolData">Input argument #1</param>
    /// <param name="experimentData">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object generateStim(Object protocolData, Object experimentData)
    {
      return mcr.EvaluateFunction("generateStim", protocolData, experimentData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] generateStim(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocolData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] generateStim(int numArgsOut, Object protocolData)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", protocolData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocolData">Input argument #1</param>
    /// <param name="experimentData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] generateStim(int numArgsOut, Object protocolData, Object 
                           experimentData)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", protocolData, experimentData);
    }


    /// <summary>
    /// Provides an interface for the generateStim function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("generateStim", 2, 2, 0)]
    protected void generateStim(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("generateStim", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the GetFromMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object GetFromMatlab()
    {
      return mcr.EvaluateFunction("GetFromMatlab", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the GetFromMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="oldVarName">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object GetFromMatlab(Object oldVarName)
    {
      return mcr.EvaluateFunction("GetFromMatlab", oldVarName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the GetFromMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] GetFromMatlab(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "GetFromMatlab", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the GetFromMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="oldVarName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] GetFromMatlab(int numArgsOut, Object oldVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "GetFromMatlab", oldVarName);
    }


    /// <summary>
    /// Provides an interface for the GetFromMatlab function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("GetFromMatlab", 1, 1, 0)]
    protected void GetFromMatlab(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("GetFromMatlab", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the getScopeVersion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object getScopeVersion()
    {
      return mcr.EvaluateFunction("getScopeVersion", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the getScopeVersion M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] getScopeVersion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "getScopeVersion", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the getScopeVersion function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("getScopeVersion", 0, 1, 0)]
    protected void getScopeVersion(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("getScopeVersion", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object getVoltTrace()
    {
      return mcr.EvaluateFunction("getVoltTrace", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object getVoltTrace(Object zData)
    {
      return mcr.EvaluateFunction("getVoltTrace", zData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object getVoltTrace(Object zData, params Object[] varargin)
    {
      Object[] argsIn= {zData, varargin};

      return mcr.EvaluateFunction("getVoltTrace", argsIn);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] getVoltTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] getVoltTrace(int numArgsOut, Object zData)
    {
      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", zData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] getVoltTrace(int numArgsOut, Object zData, params Object[] varargin)
    {
      Object[] argsIn= {zData, varargin};

      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", argsIn);
    }


    /// <summary>
    /// Provides an interface for the getVoltTrace function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("getVoltTrace", 1, 1, 1)]
    protected void getVoltTrace(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("getVoltTrace", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object highPass()
    {
      return mcr.EvaluateFunction("highPass", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object highPass(Object inData)
    {
      return mcr.EvaluateFunction("highPass", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object highPass(Object inData, Object passBand)
    {
      return mcr.EvaluateFunction("highPass", inData, passBand);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object highPass(Object inData, Object passBand, Object samplingFreq)
    {
      return mcr.EvaluateFunction("highPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] highPass(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] highPass(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] highPass(int numArgsOut, Object inData, Object passBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData, passBand);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] highPass(int numArgsOut, Object inData, Object passBand, Object 
                       samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the highPass function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("highPass", 3, 1, 0)]
    protected void highPass(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("highPass", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object histfit()
    {
      return mcr.EvaluateFunction("histfit", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object histfit(Object data)
    {
      return mcr.EvaluateFunction("histfit", data);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object histfit(Object data, params Object[] varargin)
    {
      Object[] argsIn= {data, varargin};

      return mcr.EvaluateFunction("histfit", argsIn);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] histfit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "histfit", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] histfit(int numArgsOut, Object data)
    {
      return mcr.EvaluateFunction(numArgsOut, "histfit", data);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of Objects representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] histfit(int numArgsOut, Object data, params Object[] varargin)
    {
      Object[] argsIn= {data, varargin};

      return mcr.EvaluateFunction(numArgsOut, "histfit", argsIn);
    }


    /// <summary>
    /// Provides an interface for the histfit function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("histfit", 1, 1, 1)]
    protected void histfit(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("histfit", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object intervalHist()
    {
      return mcr.EvaluateFunction("intervalHist", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object intervalHist(params Object[] varargin)
    {
      return mcr.EvaluateFunction("intervalHist", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] intervalHist(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "intervalHist", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] intervalHist(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "intervalHist", varargin);
    }


    /// <summary>
    /// Provides an interface for the intervalHist function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("intervalHist", 0, 1, 1)]
    protected void intervalHist(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("intervalHist", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object isiCv()
    {
      return mcr.EvaluateFunction("isiCv", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object isiCv(Object inData)
    {
      return mcr.EvaluateFunction("isiCv", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] isiCv(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCv", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] isiCv(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCv", inData);
    }


    /// <summary>
    /// Provides an interface for the isiCv function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("isiCv", 1, 1, 0)]
    protected void isiCv(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("isiCv", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object isiCvEvents()
    {
      return mcr.EvaluateFunction("isiCvEvents", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object isiCvEvents(params Object[] varargin)
    {
      return mcr.EvaluateFunction("isiCvEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] isiCvEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCvEvents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] isiCvEvents(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCvEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the isiCvEvents function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("isiCvEvents", 0, 1, 1)]
    protected void isiCvEvents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("isiCvEvents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object jointDist()
    {
      return mcr.EvaluateFunction("jointDist", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object jointDist(params Object[] varargin)
    {
      return mcr.EvaluateFunction("jointDist", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] jointDist(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "jointDist", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] jointDist(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "jointDist", varargin);
    }


    /// <summary>
    /// Provides an interface for the jointDist function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("jointDist", 0, 1, 1)]
    protected void jointDist(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("jointDist", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object LorenPowerSpectrum()
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object LorenPowerSpectrum(Object inData)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object LorenPowerSpectrum(Object inData, Object SamplingFreq)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object LorenPowerSpectrum(Object inData, Object SamplingFreq, Object fftPower)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq, fftPower);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <param name="windowLength">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object LorenPowerSpectrum(Object inData, Object SamplingFreq, Object fftPower, 
                               Object windowLength)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq, fftPower, windowLength);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] LorenPowerSpectrum(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] LorenPowerSpectrum(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] LorenPowerSpectrum(int numArgsOut, Object inData, Object SamplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] LorenPowerSpectrum(int numArgsOut, Object inData, Object 
                                 SamplingFreq, Object fftPower)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq, fftPower);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <param name="windowLength">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] LorenPowerSpectrum(int numArgsOut, Object inData, Object 
                                 SamplingFreq, Object fftPower, Object windowLength)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq, fftPower, windowLength);
    }


    /// <summary>
    /// Provides an interface for the LorenPowerSpectrum function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("LorenPowerSpectrum", 4, 1, 0)]
    protected void LorenPowerSpectrum(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("LorenPowerSpectrum", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object lowPass()
    {
      return mcr.EvaluateFunction("lowPass", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object lowPass(Object inData)
    {
      return mcr.EvaluateFunction("lowPass", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object lowPass(Object inData, Object passBand)
    {
      return mcr.EvaluateFunction("lowPass", inData, passBand);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object lowPass(Object inData, Object passBand, Object samplingFreq)
    {
      return mcr.EvaluateFunction("lowPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] lowPass(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] lowPass(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] lowPass(int numArgsOut, Object inData, Object passBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData, passBand);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] lowPass(int numArgsOut, Object inData, Object passBand, Object 
                      samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the lowPass function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("lowPass", 3, 1, 0)]
    protected void lowPass(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("lowPass", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeBesselFilter()
    {
      return mcr.EvaluateFunction("makeBesselFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeBesselFilter(Object samplingFreq)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeBesselFilter(Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeBesselFilter(Object samplingFreq, Object order, Object cutOffFreq)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeBesselFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeBesselFilter(int numArgsOut, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeBesselFilter(int numArgsOut, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeBesselFilter(int numArgsOut, Object samplingFreq, Object order, 
                               Object cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides an interface for the makeBesselFilter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeBesselFilter", 3, 1, 0)]
    protected void makeBesselFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeBesselFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeButterFilter()
    {
      return mcr.EvaluateFunction("makeButterFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeButterFilter(Object samplingFreq)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeButterFilter(Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeButterFilter(Object samplingFreq, Object order, Object cutOffFreq)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <param name="typeCode">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeButterFilter(Object samplingFreq, Object order, Object cutOffFreq, 
                             Object typeCode)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeButterFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeButterFilter(int numArgsOut, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeButterFilter(int numArgsOut, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeButterFilter(int numArgsOut, Object samplingFreq, Object order, 
                               Object cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <param name="typeCode">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeButterFilter(int numArgsOut, Object samplingFreq, Object order, 
                               Object cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeButterFilter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeButterFilter", 4, 1, 0)]
    protected void makeButterFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeButterFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter()
    {
      return mcr.EvaluateFunction("makeCheby1Filter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter(Object samplingFreq)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter(Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple, Object cutOffFreq)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby1Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple, Object cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple, Object cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby1Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple, Object cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeCheby1Filter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeCheby1Filter", 5, 1, 0)]
    protected void makeCheby1Filter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeCheby1Filter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter()
    {
      return mcr.EvaluateFunction("makeCheby2Filter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter(Object samplingFreq)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter(Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple, Object cutOffFreq)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeCheby2Filter(Object samplingFreq, Object order, Object 
                             PassBandRipple, Object cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple, Object cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeCheby2Filter(int numArgsOut, Object samplingFreq, Object order, 
                               Object PassBandRipple, Object cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeCheby2Filter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeCheby2Filter", 5, 1, 0)]
    protected void makeCheby2Filter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeCheby2Filter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter()
    {
      return mcr.EvaluateFunction("makeEllipFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq, Object order, Object 
                            PassBandRipple)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq, Object order, Object 
                            PassBandRipple, Object StopBandAttenuation)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq, Object order, Object 
                            PassBandRipple, Object StopBandAttenuation, Object cutOffFreq)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 6-input Objectinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <param name="typeCode">Input argument #6</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object makeEllipFilter(Object samplingFreq, Object order, Object 
                            PassBandRipple, Object StopBandAttenuation, Object 
                            cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq, Object order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq, Object order, 
                              Object PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq, Object order, 
                              Object PassBandRipple, Object StopBandAttenuation)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq, Object order, 
                              Object PassBandRipple, Object StopBandAttenuation, Object 
                              cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 6-input Object interface to the makeEllipFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <param name="typeCode">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeEllipFilter(int numArgsOut, Object samplingFreq, Object order, 
                              Object PassBandRipple, Object StopBandAttenuation, Object 
                              cutOffFreq, Object typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeEllipFilter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeEllipFilter", 6, 1, 0)]
    protected void makeEllipFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeEllipFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void makeLines()
    {
      mcr.EvaluateFunction(0, "makeLines", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void makeLines(Object traceName)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    ///
    public void makeLines(Object traceName, Object colorName)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName, colorName);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    ///
    public void makeLines(Object traceName, Object colorName, Object lineWidth)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines(int numArgsOut, Object traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines(int numArgsOut, Object traceName, Object colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName, colorName);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines(int numArgsOut, Object traceName, Object colorName, Object 
                        lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides an interface for the makeLines function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeLines", 3, 0, 0)]
    protected void makeLines(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeLines", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void makeLines2()
    {
      mcr.EvaluateFunction(0, "makeLines2", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void makeLines2(Object traceName)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    ///
    public void makeLines2(Object traceName, Object colorName)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName, colorName);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    ///
    public void makeLines2(Object traceName, Object colorName, Object lineWidth)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines2(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines2(int numArgsOut, Object traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines2(int numArgsOut, Object traceName, Object colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName, colorName);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLines2(int numArgsOut, Object traceName, Object colorName, Object 
                         lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides an interface for the makeLines2 function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeLines2", 3, 0, 0)]
    protected void makeLines2(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeLines2", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the makeLinesTest M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void makeLinesTest()
    {
      mcr.EvaluateFunction(0, "makeLinesTest", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the makeLinesTest M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] makeLinesTest(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLinesTest", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the makeLinesTest function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("makeLinesTest", 0, 0, 0)]
    protected void makeLinesTest(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("makeLinesTest", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the Matlab_Setup_Listener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void Matlab_Setup_Listener()
    {
      mcr.EvaluateFunction(0, "Matlab Setup Listener", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the Matlab_Setup_Listener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] Matlab_Setup_Listener(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "Matlab Setup Listener", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the Matlab Setup Listener function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("Matlab_Setup_Listener", 0, 0, 0)]
    protected void Matlab_Setup_Listener(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("Matlab_Setup_Listener", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlot()
    {
      return mcr.EvaluateFunction("matlabPlot", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlot(Object x)
    {
      return mcr.EvaluateFunction("matlabPlot", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlot(Object x, Object y)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlot(Object x, Object y, Object figureName)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlot(Object x, Object y, Object figureName, Object 
                       parameterString)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlot(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlot(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlot(int numArgsOut, Object x, Object y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlot(int numArgsOut, Object x, Object y, Object figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlot(int numArgsOut, Object x, Object y, Object figureName, 
                         Object parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlot function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("matlabPlot", 4, 1, 0)]
    protected void matlabPlot(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("matlabPlot", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotNoJitter()
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotNoJitter(Object x)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotNoJitter(Object x, Object y)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotNoJitter(Object x, Object y, Object figureName)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotNoJitter(Object x, Object y, Object figureName, Object 
                               parameterString)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotNoJitter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotNoJitter(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotNoJitter(int numArgsOut, Object x, Object y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotNoJitter(int numArgsOut, Object x, Object y, Object 
                                 figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotNoJitter(int numArgsOut, Object x, Object y, Object 
                                 figureName, Object parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlotNoJitter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("matlabPlotNoJitter", 4, 1, 0)]
    protected void matlabPlotNoJitter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("matlabPlotNoJitter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotOld()
    {
      return mcr.EvaluateFunction("matlabPlotOld", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotOld(Object x)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotOld(Object x, Object y)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotOld(Object x, Object y, Object figureName)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object matlabPlotOld(Object x, Object y, Object figureName, Object 
                          parameterString)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotOld(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotOld(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotOld(int numArgsOut, Object x, Object y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotOld(int numArgsOut, Object x, Object y, Object figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] matlabPlotOld(int numArgsOut, Object x, Object y, Object figureName, 
                            Object parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlotOld function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("matlabPlotOld", 4, 1, 0)]
    protected void matlabPlotOld(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("matlabPlotOld", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the MatlabSetupListener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void MatlabSetupListener()
    {
      mcr.EvaluateFunction(0, "MatlabSetupListener", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MatlabSetupListener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MatlabSetupListener(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MatlabSetupListener", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the MatlabSetupListener function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MatlabSetupListener", 0, 0, 0)]
    protected void MatlabSetupListener(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MatlabSetupListener", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object meanVariance()
    {
      return mcr.EvaluateFunction("meanVariance", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object meanVariance(Object inData)
    {
      return mcr.EvaluateFunction("meanVariance", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object meanVariance(Object inData, Object windowLength)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object meanVariance(Object inData, Object windowLength, Object overlapRatio)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength, overlapRatio);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <param name="outputAxis">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object meanVariance(Object inData, Object windowLength, Object overlapRatio, 
                         Object outputAxis)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength, overlapRatio, outputAxis);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] meanVariance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] meanVariance(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] meanVariance(int numArgsOut, Object inData, Object windowLength)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] meanVariance(int numArgsOut, Object inData, Object windowLength, 
                           Object overlapRatio)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength, overlapRatio);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <param name="outputAxis">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] meanVariance(int numArgsOut, Object inData, Object windowLength, 
                           Object overlapRatio, Object outputAxis)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength, overlapRatio, outputAxis);
    }


    /// <summary>
    /// Provides an interface for the meanVariance function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("meanVariance", 4, 1, 0)]
    protected void meanVariance(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("meanVariance", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object medianFilter()
    {
      return mcr.EvaluateFunction("medianFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="vec">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object medianFilter(Object vec)
    {
      return mcr.EvaluateFunction("medianFilter", vec);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="vec">Input argument #1</param>
    /// <param name="size">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object medianFilter(Object vec, Object size)
    {
      return mcr.EvaluateFunction("medianFilter", vec, size);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] medianFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vec">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] medianFilter(int numArgsOut, Object vec)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", vec);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vec">Input argument #1</param>
    /// <param name="size">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] medianFilter(int numArgsOut, Object vec, Object size)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", vec, size);
    }


    /// <summary>
    /// Provides an interface for the medianFilter function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("medianFilter", 2, 1, 0)]
    protected void medianFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("medianFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaBar()
    {
      return mcr.EvaluateFunction("metaBar", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaBar(Object titles)
    {
      return mcr.EvaluateFunction("metaBar", titles);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaBar(Object titles, Object xData)
    {
      return mcr.EvaluateFunction("metaBar", titles, xData);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaBar(Object titles, Object xData, Object yData)
    {
      return mcr.EvaluateFunction("metaBar", titles, xData, yData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaBar(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaBar(int numArgsOut, Object titles)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaBar(int numArgsOut, Object titles, Object xData)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles, xData);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaBar(int numArgsOut, Object titles, Object xData, Object yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles, xData, yData);
    }


    /// <summary>
    /// Provides an interface for the metaBar function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("metaBar", 3, 1, 0)]
    protected void metaBar(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("metaBar", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the metaCorrEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaCorrEvents()
    {
      return mcr.EvaluateFunction("metaCorrEvents", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the metaCorrEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object metaCorrEvents(params Object[] varargin)
    {
      return mcr.EvaluateFunction("metaCorrEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the metaCorrEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaCorrEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaCorrEvents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the metaCorrEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] metaCorrEvents(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaCorrEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the metaCorrEvents function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("metaCorrEvents", 0, 1, 1)]
    protected void metaCorrEvents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("metaCorrEvents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLdiff()
    {
      return mcr.EvaluateFunction("MLdiff", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLdiff(Object x)
    {
      return mcr.EvaluateFunction("MLdiff", x);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLdiff(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLdiff", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLdiff(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLdiff", x);
    }


    /// <summary>
    /// Provides an interface for the MLdiff function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MLdiff", 1, 1, 0)]
    protected void MLdiff(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MLdiff", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLmedfilt1()
    {
      return mcr.EvaluateFunction("MLmedfilt1", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLmedfilt1(Object x)
    {
      return mcr.EvaluateFunction("MLmedfilt1", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="n">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLmedfilt1(Object x, Object n)
    {
      return mcr.EvaluateFunction("MLmedfilt1", x, n);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLmedfilt1(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLmedfilt1(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="n">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLmedfilt1(int numArgsOut, Object x, Object n)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", x, n);
    }


    /// <summary>
    /// Provides an interface for the MLmedfilt1 function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MLmedfilt1", 2, 1, 0)]
    protected void MLmedfilt1(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MLmedfilt1", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyfit()
    {
      return mcr.EvaluateFunction("MLpolyfit", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyfit(Object x)
    {
      return mcr.EvaluateFunction("MLpolyfit", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyfit(Object x, Object y)
    {
      return mcr.EvaluateFunction("MLpolyfit", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="n">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyfit(Object x, Object y, Object n)
    {
      return mcr.EvaluateFunction("MLpolyfit", x, y, n);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyfit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyfit(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyfit(int numArgsOut, Object x, Object y)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="n">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyfit(int numArgsOut, Object x, Object y, Object n)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x, y, n);
    }


    /// <summary>
    /// Provides an interface for the MLpolyfit function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MLpolyfit", 3, 1, 0)]
    protected void MLpolyfit(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MLpolyfit", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyval()
    {
      return mcr.EvaluateFunction("MLpolyval", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyval(Object p)
    {
      return mcr.EvaluateFunction("MLpolyval", p);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLpolyval(Object p, Object x)
    {
      return mcr.EvaluateFunction("MLpolyval", p, x);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyval(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyval(int numArgsOut, Object p)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", p);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLpolyval(int numArgsOut, Object p, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", p, x);
    }


    /// <summary>
    /// Provides an interface for the MLpolyval function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MLpolyval", 2, 1, 0)]
    protected void MLpolyval(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MLpolyval", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLsgolayfilt()
    {
      return mcr.EvaluateFunction("MLsgolayfilt", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLsgolayfilt(Object x)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLsgolayfilt(Object x, Object k)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x, k);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MLsgolayfilt(Object x, Object k, Object f)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x, k, f);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLsgolayfilt(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLsgolayfilt(int numArgsOut, Object x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLsgolayfilt(int numArgsOut, Object x, Object k)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x, k);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MLsgolayfilt(int numArgsOut, Object x, Object k, Object f)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x, k, f);
    }


    /// <summary>
    /// Provides an interface for the MLsgolayfilt function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MLsgolayfilt", 3, 1, 0)]
    protected void MLsgolayfilt(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MLsgolayfilt", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingAverage()
    {
      return mcr.EvaluateFunction("movingAverage", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingAverage(Object inData)
    {
      return mcr.EvaluateFunction("movingAverage", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingAverage(Object inData, Object windowSize)
    {
      return mcr.EvaluateFunction("movingAverage", inData, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingAverage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingAverage(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingAverage(int numArgsOut, Object inData, Object windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", inData, windowSize);
    }


    /// <summary>
    /// Provides an interface for the movingAverage function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("movingAverage", 2, 1, 0)]
    protected void movingAverage(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("movingAverage", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingBlock()
    {
      return mcr.EvaluateFunction("movingBlock", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData_in1">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingBlock(Object inData_in1)
    {
      return mcr.EvaluateFunction("movingBlock", inData_in1);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData_in1">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object movingBlock(Object inData_in1, Object windowSize)
    {
      return mcr.EvaluateFunction("movingBlock", inData_in1, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingBlock(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData_in1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingBlock(int numArgsOut, Object inData_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", inData_in1);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData_in1">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] movingBlock(int numArgsOut, Object inData_in1, Object windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", inData_in1, windowSize);
    }


    /// <summary>
    /// Provides an interface for the movingBlock function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("movingBlock", 2, 1, 0)]
    protected void movingBlock(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("movingBlock", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object msec2point()
    {
      return mcr.EvaluateFunction("msec2point", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object msec2point(Object inString)
    {
      return mcr.EvaluateFunction("msec2point", inString);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object msec2point(Object inString, Object pointsPerMsec)
    {
      return mcr.EvaluateFunction("msec2point", inString, pointsPerMsec);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <param name="firstTime">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object msec2point(Object inString, Object pointsPerMsec, Object firstTime)
    {
      return mcr.EvaluateFunction("msec2point", inString, pointsPerMsec, firstTime);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] msec2point(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] msec2point(int numArgsOut, Object inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] msec2point(int numArgsOut, Object inString, Object pointsPerMsec)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString, pointsPerMsec);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <param name="firstTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] msec2point(int numArgsOut, Object inString, Object pointsPerMsec, 
                         Object firstTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString, pointsPerMsec, firstTime);
    }


    /// <summary>
    /// Provides an interface for the msec2point function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("msec2point", 3, 1, 0)]
    protected void msec2point(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("msec2point", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEO()
    {
      return mcr.EvaluateFunction("MTEO", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEO(Object inData)
    {
      return mcr.EvaluateFunction("MTEO", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEO(Object inData, Object kData)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEO(Object inData, Object kData, Object threshold)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData, threshold);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEO(Object inData, Object kData, Object threshold, Object windows)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEO(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEO(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEO(int numArgsOut, Object inData, Object kData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEO(int numArgsOut, Object inData, Object kData, Object threshold)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData, threshold);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEO(int numArgsOut, Object inData, Object kData, Object threshold, 
                   Object windows)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides an interface for the MTEO function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MTEO", 4, 1, 0)]
    protected void MTEO(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MTEO", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEOBen()
    {
      return mcr.EvaluateFunction("MTEOBen", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEOBen(Object inData)
    {
      return mcr.EvaluateFunction("MTEOBen", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEOBen(Object inData, Object kData)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEOBen(Object inData, Object kData, Object threshold)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData, threshold);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object MTEOBen(Object inData, Object kData, Object threshold, Object windows)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEOBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEOBen(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEOBen(int numArgsOut, Object inData, Object kData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEOBen(int numArgsOut, Object inData, Object kData, Object threshold)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData, threshold);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] MTEOBen(int numArgsOut, Object inData, Object kData, Object 
                      threshold, Object windows)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides an interface for the MTEOBen function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("MTEOBen", 4, 1, 0)]
    protected void MTEOBen(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("MTEOBen", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    ///
    public void newScale()
    {
      mcr.EvaluateFunction(0, "newScale", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="objectHandle">Input argument #1</param>
    ///
    public void newScale(Object objectHandle)
    {
      mcr.EvaluateFunction(0, "newScale", objectHandle);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="objectHandle">Input argument #1</param>
    /// <param name="eventInfo">Input argument #2</param>
    ///
    public void newScale(Object objectHandle, Object eventInfo)
    {
      mcr.EvaluateFunction(0, "newScale", objectHandle, eventInfo);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] newScale(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="objectHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] newScale(int numArgsOut, Object objectHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", objectHandle);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="objectHandle">Input argument #1</param>
    /// <param name="eventInfo">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] newScale(int numArgsOut, Object objectHandle, Object eventInfo)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", objectHandle, eventInfo);
    }


    /// <summary>
    /// Provides an interface for the newScale function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("newScale", 2, 0, 0)]
    protected void newScale(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("newScale", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object newScope()
    {
      return mcr.EvaluateFunction("newScope", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object newScope(params Object[] varargin)
    {
      return mcr.EvaluateFunction("newScope", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] newScope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScope", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] newScope(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScope", varargin);
    }


    /// <summary>
    /// Provides an interface for the newScope function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("newScope", 0, 1, 1)]
    protected void newScope(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("newScope", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object normalizeMatrix()
    {
      return mcr.EvaluateFunction("normalizeMatrix", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="inMatrix">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object normalizeMatrix(Object inMatrix)
    {
      return mcr.EvaluateFunction("normalizeMatrix", inMatrix);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="inMatrix">Input argument #1</param>
    /// <param name="dim">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object normalizeMatrix(Object inMatrix, Object dim)
    {
      return mcr.EvaluateFunction("normalizeMatrix", inMatrix, dim);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the normalizeMatrix M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] normalizeMatrix(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the normalizeMatrix M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inMatrix">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] normalizeMatrix(int numArgsOut, Object inMatrix)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", inMatrix);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the normalizeMatrix M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inMatrix">Input argument #1</param>
    /// <param name="dim">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] normalizeMatrix(int numArgsOut, Object inMatrix, Object dim)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", inMatrix, dim);
    }


    /// <summary>
    /// Provides an interface for the normalizeMatrix function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("normalizeMatrix", 2, 2, 0)]
    protected void normalizeMatrix(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("normalizeMatrix", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object notchFilter()
    {
      return mcr.EvaluateFunction("notchFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object notchFilter(Object inData)
    {
      return mcr.EvaluateFunction("notchFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object notchFilter(Object inData, Object samplingFreq)
    {
      return mcr.EvaluateFunction("notchFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="values">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object notchFilter(Object inData, Object samplingFreq, Object values)
    {
      return mcr.EvaluateFunction("notchFilter", inData, samplingFreq, values);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] notchFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] notchFilter(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] notchFilter(int numArgsOut, Object inData, Object samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="values">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] notchFilter(int numArgsOut, Object inData, Object samplingFreq, 
                          Object values)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData, samplingFreq, values);
    }


    /// <summary>
    /// Provides an interface for the notchFilter function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("notchFilter", 3, 1, 0)]
    protected void notchFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("notchFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object oneSidedDeviation()
    {
      return mcr.EvaluateFunction("oneSidedDeviation", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object oneSidedDeviation(Object inData)
    {
      return mcr.EvaluateFunction("oneSidedDeviation", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] oneSidedDeviation(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "oneSidedDeviation", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] oneSidedDeviation(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "oneSidedDeviation", inData);
    }


    /// <summary>
    /// Provides an interface for the oneSidedDeviation function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("oneSidedDeviation", 1, 1, 0)]
    protected void oneSidedDeviation(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("oneSidedDeviation", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    ///
    public void overlayPSPs()
    {
      mcr.EvaluateFunction(0, "overlayPSPs", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    ///
    public void overlayPSPs(Object inData)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    ///
    public void overlayPSPs(Object inData, Object timeWindow)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    ///
    public void overlayPSPs(Object inData, Object timeWindow, Object startTimes)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow, startTimes);
    }


    /// <summary>
    /// Provides a void output, 4-input Objectinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    ///
    public void overlayPSPs(Object inData, Object timeWindow, Object startTimes, Object 
                      timePerPoint)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow, startTimes, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] overlayPSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] overlayPSPs(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] overlayPSPs(int numArgsOut, Object inData, Object timeWindow)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] overlayPSPs(int numArgsOut, Object inData, Object timeWindow, Object 
                          startTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow, startTimes);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] overlayPSPs(int numArgsOut, Object inData, Object timeWindow, Object 
                          startTimes, Object timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow, startTimes, timePerPoint);
    }


    /// <summary>
    /// Provides an interface for the overlayPSPs function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("overlayPSPs", 4, 0, 0)]
    protected void overlayPSPs(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("overlayPSPs", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotAverageFreq()
    {
      return mcr.EvaluateFunction("plotAverageFreq", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotAverageFreq(params Object[] varargin)
    {
      return mcr.EvaluateFunction("plotAverageFreq", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the plotAverageFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotAverageFreq(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotAverageFreq", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the plotAverageFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotAverageFreq(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotAverageFreq", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotAverageFreq function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("plotAverageFreq", 0, 1, 1)]
    protected void plotAverageFreq(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("plotAverageFreq", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotFreq()
    {
      return mcr.EvaluateFunction("plotFreq", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotFreq(params Object[] varargin)
    {
      return mcr.EvaluateFunction("plotFreq", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotFreq(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotFreq", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotFreq(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotFreq", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotFreq function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("plotFreq", 0, 1, 1)]
    protected void plotFreq(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("plotFreq", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotHistogram()
    {
      return mcr.EvaluateFunction("plotHistogram", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotHistogram(Object inValues)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotHistogram(Object inValues, Object xAxisBins)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues, xAxisBins);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotHistogram(Object inValues, Object xAxisBins, Object figureName)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues, xAxisBins, figureName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotHistogram(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotHistogram(int numArgsOut, Object inValues)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotHistogram(int numArgsOut, Object inValues, Object xAxisBins)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues, xAxisBins);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotHistogram(int numArgsOut, Object inValues, Object xAxisBins, 
                            Object figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues, xAxisBins, figureName);
    }


    /// <summary>
    /// Provides an interface for the plotHistogram function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("plotHistogram", 3, 1, 0)]
    protected void plotHistogram(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("plotHistogram", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotPercentCorrelation()
    {
      return mcr.EvaluateFunction("plotPercentCorrelation", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object plotPercentCorrelation(params Object[] varargin)
    {
      return mcr.EvaluateFunction("plotPercentCorrelation", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotPercentCorrelation(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotPercentCorrelation", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of Objects representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] plotPercentCorrelation(int numArgsOut, params Object[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotPercentCorrelation", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotPercentCorrelation function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("plotPercentCorrelation", 0, 1, 1)]
    protected void plotPercentCorrelation(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("plotPercentCorrelation", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object prepForPrint()
    {
      return mcr.EvaluateFunction("prepForPrint", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object prepForPrint(Object currentAxis)
    {
      return mcr.EvaluateFunction("prepForPrint", currentAxis);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object prepForPrint(Object currentAxis, Object yVal)
    {
      return mcr.EvaluateFunction("prepForPrint", currentAxis, yVal);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <param name="varargin">Array of Objects representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object prepForPrint(Object currentAxis, Object yVal, params Object[] varargin)
    {
      Object[] argsIn= {currentAxis, yVal, varargin};

      return mcr.EvaluateFunction("prepForPrint", argsIn);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] prepForPrint(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] prepForPrint(int numArgsOut, Object currentAxis)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", currentAxis);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] prepForPrint(int numArgsOut, Object currentAxis, Object yVal)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", currentAxis, yVal);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <param name="varargin">Array of Objects representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] prepForPrint(int numArgsOut, Object currentAxis, Object yVal, params 
                           Object[] varargin)
    {
      Object[] argsIn= {currentAxis, yVal, varargin};

      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", argsIn);
    }


    /// <summary>
    /// Provides an interface for the prepForPrint function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("prepForPrint", 2, 1, 1)]
    protected void prepForPrint(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("prepForPrint", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    ///
    public void printWithAxes()
    {
      mcr.EvaluateFunction(0, "printWithAxes", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void printWithAxes(Object figure)
    {
      mcr.EvaluateFunction(0, "printWithAxes", figure);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] printWithAxes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithAxes", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] printWithAxes(int numArgsOut, Object figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithAxes", figure);
    }


    /// <summary>
    /// Provides an interface for the printWithAxes function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("printWithAxes", 1, 0, 0)]
    protected void printWithAxes(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("printWithAxes", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    ///
    public void printWithScaleBars()
    {
      mcr.EvaluateFunction(0, "printWithScaleBars", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void printWithScaleBars(Object figure)
    {
      mcr.EvaluateFunction(0, "printWithScaleBars", figure);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] printWithScaleBars(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithScaleBars", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] printWithScaleBars(int numArgsOut, Object figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithScaleBars", figure);
    }


    /// <summary>
    /// Provides an interface for the printWithScaleBars function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("printWithScaleBars", 1, 0, 0)]
    protected void printWithScaleBars(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("printWithScaleBars", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBen()
    {
      return mcr.EvaluateFunction("readBen", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBen(Object filename)
    {
      return mcr.EvaluateFunction("readBen", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBen(Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction("readBen", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBen(int numArgsOut, Object filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", filename);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBen(int numArgsOut, Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBen function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("readBen", 2, 1, 0)]
    protected void readBen(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("readBen", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenNewStyle()
    {
      return mcr.EvaluateFunction("readBenNewStyle", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenNewStyle(Object filename)
    {
      return mcr.EvaluateFunction("readBenNewStyle", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenNewStyle(Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction("readBenNewStyle", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the readBenNewStyle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenNewStyle(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the readBenNewStyle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenNewStyle(int numArgsOut, Object filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", filename);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the readBenNewStyle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenNewStyle(int numArgsOut, Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBenNewStyle function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("readBenNewStyle", 2, 1, 0)]
    protected void readBenNewStyle(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("readBenNewStyle", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenOld2()
    {
      return mcr.EvaluateFunction("readBenOld2", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenOld2(Object filename)
    {
      return mcr.EvaluateFunction("readBenOld2", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readBenOld2(Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction("readBenOld2", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenOld2(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenOld2(int numArgsOut, Object filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", filename);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readBenOld2(int numArgsOut, Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBenOld2 function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("readBenOld2", 2, 1, 0)]
    protected void readBenOld2(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("readBenOld2", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readTrace()
    {
      return mcr.EvaluateFunction("readTrace", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readTrace(Object filename)
    {
      return mcr.EvaluateFunction("readTrace", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readTrace(Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction("readTrace", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readTrace(int numArgsOut, Object filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", filename);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readTrace(int numArgsOut, Object filename, Object infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readTrace function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("readTrace", 2, 1, 0)]
    protected void readTrace(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("readTrace", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readVBString()
    {
      return mcr.EvaluateFunction("readVBString", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="fid">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object readVBString(Object fid)
    {
      return mcr.EvaluateFunction("readVBString", fid);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readVBString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readVBString", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="fid">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] readVBString(int numArgsOut, Object fid)
    {
      return mcr.EvaluateFunction(numArgsOut, "readVBString", fid);
    }


    /// <summary>
    /// Provides an interface for the readVBString function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("readVBString", 1, 1, 0)]
    protected void readVBString(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("readVBString", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the refreshAllScopes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void refreshAllScopes()
    {
      mcr.EvaluateFunction(0, "refreshAllScopes", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the refreshAllScopes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] refreshAllScopes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "refreshAllScopes", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the refreshAllScopes function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("refreshAllScopes", 0, 0, 0)]
    protected void refreshAllScopes(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("refreshAllScopes", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object removeTrace()
    {
      return mcr.EvaluateFunction("removeTrace", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object removeTrace(Object channelName)
    {
      return mcr.EvaluateFunction("removeTrace", channelName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] removeTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "removeTrace", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] removeTrace(int numArgsOut, Object channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "removeTrace", channelName);
    }


    /// <summary>
    /// Provides an interface for the removeTrace function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("removeTrace", 1, 1, 0)]
    protected void removeTrace(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("removeTrace", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object replaceTrace()
    {
      return mcr.EvaluateFunction("replaceTrace", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object replaceTrace(Object newData)
    {
      return mcr.EvaluateFunction("replaceTrace", newData);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object replaceTrace(Object newData, Object channelName)
    {
      return mcr.EvaluateFunction("replaceTrace", newData, channelName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] replaceTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] replaceTrace(int numArgsOut, Object newData)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", newData);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] replaceTrace(int numArgsOut, Object newData, Object channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", newData, channelName);
    }


    /// <summary>
    /// Provides an interface for the replaceTrace function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("replaceTrace", 2, 1, 0)]
    protected void replaceTrace(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("replaceTrace", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the restartSystem M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this should run when caught error is found
    /// </remarks>
    ///
    public void restartSystem()
    {
      mcr.EvaluateFunction(0, "restartSystem", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the restartSystem M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this should run when caught error is found
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] restartSystem(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "restartSystem", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the restartSystem function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this should run when caught error is found
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("restartSystem", 0, 0, 0)]
    protected void restartSystem(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("restartSystem", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object runGeneralFilter()
    {
      return mcr.EvaluateFunction("runGeneralFilter", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object runGeneralFilter(Object inData)
    {
      return mcr.EvaluateFunction("runGeneralFilter", inData);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] runGeneralFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "runGeneralFilter", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] runGeneralFilter(int numArgsOut, Object inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "runGeneralFilter", inData);
    }


    /// <summary>
    /// Provides an interface for the runGeneralFilter function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("runGeneralFilter", 1, 1, 0)]
    protected void runGeneralFilter(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("runGeneralFilter", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile()
    {
      return mcr.EvaluateFunction("SaveAsMatFile", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile(Object inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newFileName">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile(Object inArray, Object newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile", inArray, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newFileName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile(int numArgsOut, Object inArray, Object newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", inArray, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SaveAsMatFile", 2, 1, 0)]
    protected void SaveAsMatFile(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SaveAsMatFile", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile2Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile2Vectors(Object inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile2Vectors(Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="newFileName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile2Vectors(Object inArray, Object inArray2, Object 
                                  newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray, inArray2, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile2Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile2Vectors(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile2Vectors(int numArgsOut, Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="newFileName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile2Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray, inArray2, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile2Vectors function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SaveAsMatFile2Vectors", 3, 1, 0)]
    protected void SaveAsMatFile2Vectors(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SaveAsMatFile2Vectors", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3Vectors(Object inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3Vectors(Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3Vectors(Object inArray, Object inArray2, Object inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3Vectors(Object inArray, Object inArray2, Object inArray3, 
                                  Object newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3Vectors(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3Vectors(int numArgsOut, Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object inArray3, Object newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile3Vectors function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SaveAsMatFile3Vectors", 4, 1, 0)]
    protected void SaveAsMatFile3Vectors(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SaveAsMatFile3Vectors", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique()
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique(Object inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique(Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique(Object inArray, Object inArray2, Object 
                                        inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique(Object inArray, Object inArray2, Object 
                                        inArray3, Object newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <param name="newVarName">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile3VectorsUnique(Object inArray, Object inArray2, Object 
                                        inArray3, Object newFileName, Object newVarName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName, newVarName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut, Object inArray, Object 
                                          inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut, Object inArray, Object 
                                          inArray2, Object inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut, Object inArray, Object 
                                          inArray2, Object inArray3, Object newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the SaveAsMatFile3VectorsUnique
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <param name="newVarName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile3VectorsUnique(int numArgsOut, Object inArray, Object 
                                          inArray2, Object inArray3, Object newFileName, 
                                          Object newVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName, newVarName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile3VectorsUnique function in which the
    /// input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SaveAsMatFile3VectorsUnique", 5, 1, 0)]
    protected void SaveAsMatFile3VectorsUnique(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SaveAsMatFile3VectorsUnique", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors(Object inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors(Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors(Object inArray, Object inArray2, Object inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors(Object inArray, Object inArray2, Object inArray3, 
                                  Object inArray4)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4);
    }


    /// <summary>
    /// Provides a single output, 5-input Objectinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <param name="newFileName">Input argument #5</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SaveAsMatFile4Vectors(Object inArray, Object inArray2, Object inArray3, 
                                  Object inArray4, Object newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut, Object inArray, Object inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object inArray3, Object inArray4)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <param name="newFileName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SaveAsMatFile4Vectors(int numArgsOut, Object inArray, Object 
                                    inArray2, Object inArray3, Object inArray4, Object 
                                    newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile4Vectors function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SaveAsMatFile4Vectors", 5, 1, 0)]
    protected void SaveAsMatFile4Vectors(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SaveAsMatFile4Vectors", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object sec2time()
    {
      return mcr.EvaluateFunction("sec2time", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numSecs">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object sec2time(Object numSecs)
    {
      return mcr.EvaluateFunction("sec2time", numSecs);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sec2time(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sec2time", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="numSecs">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sec2time(int numArgsOut, Object numSecs)
    {
      return mcr.EvaluateFunction(numArgsOut, "sec2time", numSecs);
    }


    /// <summary>
    /// Provides an interface for the sec2time function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sec2time", 1, 1, 0)]
    protected void sec2time(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sec2time", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendFilenamesToScope()
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScope", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendFilenamesToScope(Object commaList)
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScope", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendFilenamesToScope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScope", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendFilenamesToScope(int numArgsOut, Object commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScope", commaList);
    }


    /// <summary>
    /// Provides an interface for the sendFilenamesToScope function in which the input
    /// and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sendFilenamesToScope", 1, 0, 0)]
    protected void sendFilenamesToScope(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sendFilenamesToScope", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendFilenamesToScopeNoRefresh()
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScopeNoRefresh", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendFilenamesToScopeNoRefresh(Object commaList)
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScopeNoRefresh", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendFilenamesToScopeNoRefresh(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScopeNoRefresh", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendFilenamesToScopeNoRefresh(int numArgsOut, Object commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScopeNoRefresh", commaList);
    }


    /// <summary>
    /// Provides an interface for the sendFilenamesToScopeNoRefresh function in which the
    /// input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sendFilenamesToScopeNoRefresh", 1, 0, 0)]
    protected void sendFilenamesToScopeNoRefresh(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sendFilenamesToScopeNoRefresh", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void sendMessage()
    {
      mcr.EvaluateFunction(0, "sendMessage", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="message">Input argument #1</param>
    ///
    public void sendMessage(Object message)
    {
      mcr.EvaluateFunction(0, "sendMessage", message);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendMessage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendMessage", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="message">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendMessage(int numArgsOut, Object message)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendMessage", message);
    }


    /// <summary>
    /// Provides an interface for the sendMessage function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sendMessage", 1, 0, 0)]
    protected void sendMessage(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sendMessage", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendText()
    {
      mcr.EvaluateFunction(0, "sendText", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendText(Object commaList)
    {
      mcr.EvaluateFunction(0, "sendText", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendText", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sendText(int numArgsOut, Object commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendText", commaList);
    }


    /// <summary>
    /// Provides an interface for the sendText function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sendText", 1, 0, 0)]
    protected void sendText(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sendText", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SendToMatlab()
    {
      return mcr.EvaluateFunction("SendToMatlab", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SendToMatlab(Object inArray)
    {
      return mcr.EvaluateFunction("SendToMatlab", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newVarName">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SendToMatlab(Object inArray, Object newVarName)
    {
      return mcr.EvaluateFunction("SendToMatlab", inArray, newVarName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SendToMatlab(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SendToMatlab(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newVarName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SendToMatlab(int numArgsOut, Object inArray, Object newVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", inArray, newVarName);
    }


    /// <summary>
    /// Provides an interface for the SendToMatlab function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SendToMatlab", 2, 1, 0)]
    protected void SendToMatlab(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SendToMatlab", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void setAxisLabels()
    {
      mcr.EvaluateFunction(0, "setAxisLabels", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void setAxisLabels(Object axisHandle)
    {
      mcr.EvaluateFunction(0, "setAxisLabels", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] setAxisLabels(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "setAxisLabels", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] setAxisLabels(int numArgsOut, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "setAxisLabels", axisHandle);
    }


    /// <summary>
    /// Provides an interface for the setAxisLabels function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("setAxisLabels", 1, 0, 0)]
    protected void setAxisLabels(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("setAxisLabels", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object sfigure()
    {
      return mcr.EvaluateFunction("sfigure", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="h_in1">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object sfigure(Object h_in1)
    {
      return mcr.EvaluateFunction("sfigure", h_in1);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sfigure(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sfigure", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="h_in1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] sfigure(int numArgsOut, Object h_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "sfigure", h_in1);
    }


    /// <summary>
    /// Provides an interface for the sfigure function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("sfigure", 1, 1, 0)]
    protected void sfigure(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("sfigure", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SGfilterBen()
    {
      return mcr.EvaluateFunction("SGfilterBen", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SGfilterBen(Object InVector)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SGfilterBen(Object InVector, Object PolyOrder)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object SGfilterBen(Object InVector, Object PolyOrder, Object FrameSize)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SGfilterBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SGfilterBen(int numArgsOut, Object InVector)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SGfilterBen(int numArgsOut, Object InVector, Object PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] SGfilterBen(int numArgsOut, Object InVector, Object PolyOrder, Object 
                          FrameSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides an interface for the SGfilterBen function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("SGfilterBen", 3, 1, 0)]
    protected void SGfilterBen(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("SGfilterBen", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    ///
    public void showEvents()
    {
      mcr.EvaluateFunction(0, "showEvents", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void showEvents(Object axisHandle)
    {
      mcr.EvaluateFunction(0, "showEvents", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showEvents", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showEvents(int numArgsOut, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showEvents", axisHandle);
    }


    /// <summary>
    /// Provides an interface for the showEvents function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("showEvents", 1, 0, 0)]
    protected void showEvents(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("showEvents", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object showFFT()
    {
      return mcr.EvaluateFunction("showFFT", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object showFFT(Object dataIn)
    {
      return mcr.EvaluateFunction("showFFT", dataIn);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object showFFT(Object dataIn, Object samplingRate)
    {
      return mcr.EvaluateFunction("showFFT", dataIn, samplingRate);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object showFFT(Object dataIn, Object samplingRate, Object figureName)
    {
      return mcr.EvaluateFunction("showFFT", dataIn, samplingRate, figureName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFFT(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFFT(int numArgsOut, Object dataIn)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFFT(int numArgsOut, Object dataIn, Object samplingRate)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn, samplingRate);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFFT(int numArgsOut, Object dataIn, Object samplingRate, Object 
                      figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn, samplingRate, figureName);
    }


    /// <summary>
    /// Provides an interface for the showFFT function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("showFFT", 3, 1, 0)]
    protected void showFFT(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("showFFT", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    ///
    public void showFrameMarker()
    {
      mcr.EvaluateFunction(0, "showFrameMarker", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void showFrameMarker(Object axisHandle)
    {
      mcr.EvaluateFunction(0, "showFrameMarker", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the showFrameMarker M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFrameMarker(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFrameMarker", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the showFrameMarker M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showFrameMarker(int numArgsOut, Object axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFrameMarker", axisHandle);
    }


    /// <summary>
    /// Provides an interface for the showFrameMarker function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("showFrameMarker", 1, 0, 0)]
    protected void showFrameMarker(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("showFrameMarker", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    ///
    public void showStims()
    {
      mcr.EvaluateFunction(0, "showStims", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    ///
    public void showStims(Object figHandle)
    {
      mcr.EvaluateFunction(0, "showStims", figHandle);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    /// <param name="showLegend">Input argument #2</param>
    ///
    public void showStims(Object figHandle, Object showLegend)
    {
      mcr.EvaluateFunction(0, "showStims", figHandle, showLegend);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showStims(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showStims(int numArgsOut, Object figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", figHandle);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <param name="showLegend">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] showStims(int numArgsOut, Object figHandle, Object showLegend)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", figHandle, showLegend);
    }


    /// <summary>
    /// Provides an interface for the showStims function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("showStims", 2, 0, 0)]
    protected void showStims(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("showStims", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the startInterprocess
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void startInterprocess()
    {
      mcr.EvaluateFunction(0, "startInterprocess", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the startInterprocess
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] startInterprocess(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "startInterprocess", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the startInterprocess function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("startInterprocess", 0, 0, 0)]
    protected void startInterprocess(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("startInterprocess", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the testDrawLine M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testDrawLine()
    {
      mcr.EvaluateFunction(0, "testDrawLine", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the testDrawLine M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] testDrawLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testDrawLine", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the testDrawLine function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("testDrawLine", 0, 0, 0)]
    protected void testDrawLine(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("testDrawLine", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the testMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testMessage()
    {
      mcr.EvaluateFunction(0, "testMessage", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the testMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] testMessage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessage", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the testMessage function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("testMessage", 0, 0, 0)]
    protected void testMessage(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("testMessage", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testMessageString()
    {
      mcr.EvaluateFunction(0, "testMessageString", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    ///
    public void testMessageString(Object inString)
    {
      mcr.EvaluateFunction(0, "testMessageString", inString);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] testMessageString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessageString", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] testMessageString(int numArgsOut, Object inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessageString", inString);
    }


    /// <summary>
    /// Provides an interface for the testMessageString function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("testMessageString", 1, 0, 0)]
    protected void testMessageString(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("testMessageString", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object timeControl()
    {
      return mcr.EvaluateFunction("timeControl", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="right">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object timeControl(Object right)
    {
      return mcr.EvaluateFunction("timeControl", right);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="right">Input argument #1</param>
    /// <param name="bottom">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object timeControl(Object right, Object bottom)
    {
      return mcr.EvaluateFunction("timeControl", right, bottom);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] timeControl(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="right">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] timeControl(int numArgsOut, Object right)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", right);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="right">Input argument #1</param>
    /// <param name="bottom">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] timeControl(int numArgsOut, Object right, Object bottom)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", right, bottom);
    }


    /// <summary>
    /// Provides an interface for the timeControl function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("timeControl", 2, 1, 0)]
    protected void timeControl(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("timeControl", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object VBmedian()
    {
      return mcr.EvaluateFunction("VBmedian", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object VBmedian(Object inArray)
    {
      return mcr.EvaluateFunction("VBmedian", inArray);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] VBmedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmedian", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] VBmedian(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmedian", inArray);
    }


    /// <summary>
    /// Provides an interface for the VBmedian function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("VBmedian", 1, 1, 0)]
    protected void VBmedian(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("VBmedian", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object VBmovingMedian()
    {
      return mcr.EvaluateFunction("VBmovingMedian", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object VBmovingMedian(Object inArray)
    {
      return mcr.EvaluateFunction("VBmovingMedian", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object VBmovingMedian(Object inArray, Object windowSize)
    {
      return mcr.EvaluateFunction("VBmovingMedian", inArray, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] VBmovingMedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] VBmovingMedian(int numArgsOut, Object inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] VBmovingMedian(int numArgsOut, Object inArray, Object windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", inArray, windowSize);
    }


    /// <summary>
    /// Provides an interface for the VBmovingMedian function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("VBmovingMedian", 2, 1, 0)]
    protected void VBmovingMedian(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("VBmovingMedian", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the wakeUp M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void wakeUp()
    {
      mcr.EvaluateFunction(0, "wakeUp", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the wakeUp M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] wakeUp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "wakeUp", new Object[]{});
    }


    /// <summary>
    /// Provides an interface for the wakeUp function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("wakeUp", 0, 0, 0)]
    protected void wakeUp(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("wakeUp", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a single output, 0-input Objectinterface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object whichChannel()
    {
      return mcr.EvaluateFunction("whichChannel", new Object[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input Objectinterface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object whichChannel(Object protocol)
    {
      return mcr.EvaluateFunction("whichChannel", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input Objectinterface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object whichChannel(Object protocol, Object ampNum)
    {
      return mcr.EvaluateFunction("whichChannel", protocol, ampNum);
    }


    /// <summary>
    /// Provides a single output, 3-input Objectinterface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <param name="channelType">Input argument #3</param>
    /// <returns>An Object containing the first output argument.</returns>
    ///
    public Object whichChannel(Object protocol, Object ampNum, Object channelType)
    {
      return mcr.EvaluateFunction("whichChannel", protocol, ampNum, channelType);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whichChannel(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whichChannel(int numArgsOut, Object protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whichChannel(int numArgsOut, Object protocol, Object ampNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol, ampNum);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <param name="channelType">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whichChannel(int numArgsOut, Object protocol, Object ampNum, Object 
                           channelType)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol, ampNum, channelType);
    }


    /// <summary>
    /// Provides an interface for the whichChannel function in which the input and output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("whichChannel", 3, 1, 0)]
    protected void whichChannel(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("whichChannel", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }
    /// <summary>
    /// Provides a void output, 0-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    ///
    public void whiteNoiseFile()
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", new Object[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    ///
    public void whiteNoiseFile(Object samplingRate)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate);
    }


    /// <summary>
    /// Provides a void output, 2-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    ///
    public void whiteNoiseFile(Object samplingRate, Object duration)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration);
    }


    /// <summary>
    /// Provides a void output, 3-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    ///
    public void whiteNoiseFile(Object samplingRate, Object duration, Object peakToPeak)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak);
    }


    /// <summary>
    /// Provides a void output, 4-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    ///
    public void whiteNoiseFile(Object samplingRate, Object duration, Object peakToPeak, 
                         Object cutoff)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff);
    }


    /// <summary>
    /// Provides a void output, 5-input Objectinterface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <param name="fileName">Input argument #5</param>
    ///
    public void whiteNoiseFile(Object samplingRate, Object duration, Object peakToPeak, 
                         Object cutoff, Object fileName)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff, fileName);
    }


    /// <summary>
    /// Provides the standard 0-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", new Object[]{});
    }


    /// <summary>
    /// Provides the standard 1-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut, Object samplingRate)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate);
    }


    /// <summary>
    /// Provides the standard 2-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut, Object samplingRate, Object duration)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration);
    }


    /// <summary>
    /// Provides the standard 3-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut, Object samplingRate, Object duration, 
                             Object peakToPeak)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak);
    }


    /// <summary>
    /// Provides the standard 4-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut, Object samplingRate, Object duration, 
                             Object peakToPeak, Object cutoff)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff);
    }


    /// <summary>
    /// Provides the standard 5-input Object interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <param name="fileName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public Object[] whiteNoiseFile(int numArgsOut, Object samplingRate, Object duration, 
                             Object peakToPeak, Object cutoff, Object fileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff, fileName);
    }


    /// <summary>
    /// Provides an interface for the whiteNoiseFile function in which the input and
    /// output
    /// arguments are specified as an array of Objects.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of Object output arguments</param>
    /// <param name= "argsIn">Array of Object input arguments</param>
    /// <param name= "varArgsIn">Array of Object representing variable input
    /// arguments</param>
    ///
    [MATLABSignature("whiteNoiseFile", 5, 0, 0)]
    protected void whiteNoiseFile(int numArgsOut, ref Object[] argsOut, Object[] argsIn, params Object[] varArgsIn)
    {
        mcr.EvaluateFunctionForTypeSafeCall("whiteNoiseFile", numArgsOut, ref argsOut, argsIn, varArgsIn);
    }

    /// <summary>
    /// This method will cause a MATLAB figure window to behave as a modal dialog box.
    /// The method will not return until all the figure windows associated with this
    /// component have been closed.
    /// </summary>
    /// <remarks>
    /// An application should only call this method when required to keep the
    /// MATLAB figure window from disappearing.  Other techniques, such as calling
    /// Console.ReadLine() from the application should be considered where
    /// possible.</remarks>
    ///
    public void WaitForFiguresToDie()
    {
      mcr.WaitForFiguresToDie();
    }



    #endregion Methods

    #region Class Members

    private static MWMCR mcr= null;

    private bool disposed= false;

    #endregion Class Members
  }
}
