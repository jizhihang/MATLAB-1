/*
* MATLAB Compiler: 4.16 (R2011b)
* Date: Fri Feb 10 20:47:07 2012
* Arguments: "-B" "macro_default" "-W" "dotnet:mPhys,Class1,0.0,private" "-T" "link:lib"
* "-d" "d:\Synapse System\Matlab Scope for NET oneFolder\mFiles\mPhys\src" "-N" "-p"
* "curvefit" "-p" "signal" "-p" "stats" "-w" "enable:specified_file_mismatch" "-w"
* "enable:repeated_file" "-w" "enable:switch_ignored" "-w" "enable:missing_lib_sentinel"
* "-w" "enable:demo_license" "-v" "class{Class1:D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addFunctionToPlot.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addStatusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\addTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\analysisAxis.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apHeight.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apRiseFallRatio.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apThreshold.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apWidth.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\apWidthHM.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\autoCorrelate.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\autoNotch.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\bandStop.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benConv.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benDisplayString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benEventsOld.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenFitLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenFitPolynomial.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benGenerateStim.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benPeakAllPoints.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benPeakAllPointsTenths.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benProtocolViewer.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benStats1Array.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\benStats2Arrays.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenVectorMedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenWrapPolyFit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\BenWrapSGolayFilt.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\besselFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\blankAPsWithConstant.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\blankAPsWithNaNs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\burstingProbability.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcBurstProb.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcMean.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcSTA.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\calcSTO.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\cell2mat.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\characterizePSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\clearBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\clearExtraLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\colorSpread.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\combFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\commonEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\Contents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\crossCorr.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\crosscorrelateSetup.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectAPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectPSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectPSPs3d.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\detectSpikes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\displayEventLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\displayEventLinesSimple.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\dumpPreferences.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\evaluateBonusText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\evaluateExportText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\eventTriggeredAverage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\executeMatlabLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportToRDrive.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportWithAxes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\exportWithScaleBars.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fastAHP.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fastAHPSlope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fcnMin.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\findSteps.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\findStims.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit1Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit2Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fit3Exp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitAlpha.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitBoltzmann.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitBoltzmannBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecayDouble.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecaySingle.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitDecayTriple.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitLineExtra.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fitSine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\fourier.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\generateStim.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\GetFromMatlab.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\getScopeVersion.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\getVoltTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\highPass.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\histfit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\intervalHist.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\isiCv.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\isiCvEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\jointDist.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\LorenPowerSpectrum.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\lowPass.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeBesselFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeButterFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeCheby1Filter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeCheby2Filter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeEllipFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLines.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLines2.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\makeLinesTest.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\Matlab Setup Listener.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlot.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlotNoJitter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\matlabPlotOld.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MatlabSetupListener.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\meanVariance.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\medianFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\metaBar.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\metaCorrEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLdiff.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLmedfilt1.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLpolyfit.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLpolyval.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MLsgolayfilt.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\movingAverage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\movingBlock.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\msec2point.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MTEO.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\MTEOBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\newScale.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\newScope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\normalizeMatrix.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\notchFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\oneSidedDeviation.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\overlayPSPs.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotAverageFreq.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotFreq.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotHistogram.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\plotPercentCorrelation.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\prepForPrint.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\printWithAxes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\printWithScaleBars.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBenNewStyle.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readBenOld2.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\readVBString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\refreshAllScopes.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\removeTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\replaceTrace.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\restartSystem.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\runGeneralFilter.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile2Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile3Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile3VectorsUnique.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SaveAsMatFile4Vectors.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sec2time.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendFilenamesToScope.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendFilenamesToScopeNoRefresh.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendMessage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sendText.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SendToMatlab.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\setAxisLabels.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\sfigure.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\SGfilterBen.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showEvents.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showFFT.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showFrameMarker.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\showStims.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\startInterprocess.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testDrawLine.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testMessage.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\testMessageString.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\timeControl.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\VBmedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\VBmovingMedian.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\wakeUp.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\whichChannel.m,D:\Synapse System\Matlab Scope for NET
* oneFolder\mFiles\whiteNoiseFile.m}" 
*/
using System;
using System.Reflection;
using System.IO;
using MathWorks.MATLAB.NET.Arrays;
using MathWorks.MATLAB.NET.Utility;

#if SHARED
[assembly: System.Reflection.AssemblyKeyFile(@"")]
#endif

namespace mPhys
{

  /// <summary>
  /// The Class1 class provides a CLS compliant, MWArray interface to the M-functions
  /// contained in the files:
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addFunctionToPlot.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addStatusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\addTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\analysisAxis.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apHeight.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apRiseFallRatio.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apThreshold.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apWidth.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\apWidthHM.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\autoCorrelate.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\autoNotch.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\bandStop.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benConv.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benDisplayString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benEventsOld.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenFitLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenFitPolynomial.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benGenerateStim.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benPeakAllPoints.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benPeakAllPointsTenths.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benProtocolViewer.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benStats1Array.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\benStats2Arrays.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenVectorMedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenWrapPolyFit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\BenWrapSGolayFilt.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\besselFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\blankAPsWithConstant.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\blankAPsWithNaNs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\burstingProbability.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcBurstProb.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcMean.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcSTA.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\calcSTO.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\cell2mat.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\characterizePSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\clearBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\clearExtraLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\colorSpread.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\combFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\commonEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\Contents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\crossCorr.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\crosscorrelateSetup.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectAPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectPSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectPSPs3d.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\detectSpikes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\displayEventLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\displayEventLinesSimple.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\dumpPreferences.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\evaluateBonusText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\evaluateExportText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\eventTriggeredAverage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\executeMatlabLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportToRDrive.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportWithAxes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\exportWithScaleBars.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fastAHP.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fastAHPSlope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fcnMin.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\findSteps.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\findStims.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit1Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit2Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fit3Exp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitAlpha.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitBoltzmann.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitBoltzmannBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecayDouble.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecaySingle.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitDecayTriple.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitLineExtra.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fitSine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\fourier.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\generateStim.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\GetFromMatlab.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\getScopeVersion.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\getVoltTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\highPass.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\histfit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\intervalHist.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\isiCv.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\isiCvEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\jointDist.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\LorenPowerSpectrum.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\lowPass.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeBesselFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeButterFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeCheby1Filter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeCheby2Filter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeEllipFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLines.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLines2.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\makeLinesTest.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\Matlab Setup Listener.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlot.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlotNoJitter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\matlabPlotOld.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MatlabSetupListener.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\meanVariance.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\medianFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\metaBar.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\metaCorrEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLdiff.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLmedfilt1.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLpolyfit.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLpolyval.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MLsgolayfilt.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\movingAverage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\movingBlock.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\msec2point.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MTEO.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\MTEOBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\newScale.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\newScope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\normalizeMatrix.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\notchFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\oneSidedDeviation.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\overlayPSPs.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotAverageFreq.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotFreq.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotHistogram.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\plotPercentCorrelation.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\prepForPrint.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\printWithAxes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\printWithScaleBars.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBenNewStyle.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readBenOld2.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\readVBString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\refreshAllScopes.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\removeTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\replaceTrace.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\restartSystem.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\runGeneralFilter.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile2Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile3Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET
  /// oneFolder\mFiles\SaveAsMatFile3VectorsUnique.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SaveAsMatFile4Vectors.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sec2time.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendFilenamesToScope.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET
  /// oneFolder\mFiles\sendFilenamesToScopeNoRefresh.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendMessage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sendText.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SendToMatlab.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\setAxisLabels.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\sfigure.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\SGfilterBen.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showEvents.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showFFT.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showFrameMarker.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\showStims.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\startInterprocess.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testDrawLine.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testMessage.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\testMessageString.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\timeControl.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\VBmedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\VBmovingMedian.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\wakeUp.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\whichChannel.m
  /// <newpara></newpara>
  /// D:\Synapse System\Matlab Scope for NET oneFolder\mFiles\whiteNoiseFile.m
  /// <newpara></newpara>
  /// deployprint.m
  /// <newpara></newpara>
  /// printdlg.m
  /// </summary>
  /// <remarks>
  /// @Version 0.0
  /// </remarks>
  public class Class1 : IDisposable
  {
    #region Constructors

    /// <summary internal= "true">
    /// The static constructor instantiates and initializes the MATLAB Compiler Runtime
    /// instance.
    /// </summary>
    static Class1()
    {
      if (MWMCR.MCRAppInitialized)
      {
        Assembly assembly= Assembly.GetExecutingAssembly();

        string ctfFilePath= assembly.Location;

        int lastDelimiter= ctfFilePath.LastIndexOf(@"\");

        ctfFilePath= ctfFilePath.Remove(lastDelimiter, (ctfFilePath.Length - lastDelimiter));

        string ctfFileName = "mPhys.ctf";

        Stream embeddedCtfStream = null;

        String[] resourceStrings = assembly.GetManifestResourceNames();

        foreach (String name in resourceStrings)
        {
          if (name.Contains(ctfFileName))
          {
            embeddedCtfStream = assembly.GetManifestResourceStream(name);
            break;
          }
        }
        mcr= new MWMCR("",
                       ctfFilePath, embeddedCtfStream, true);
      }
      else
      {
        throw new ApplicationException("MWArray assembly could not be initialized");
      }
    }


    /// <summary>
    /// Constructs a new instance of the Class1 class.
    /// </summary>
    public Class1()
    {
    }


    #endregion Constructors

    #region Finalize

    /// <summary internal= "true">
    /// Class destructor called by the CLR garbage collector.
    /// </summary>
    ~Class1()
    {
      Dispose(false);
    }


    /// <summary>
    /// Frees the native resources associated with this object
    /// </summary>
    public void Dispose()
    {
      Dispose(true);

      GC.SuppressFinalize(this);
    }


    /// <summary internal= "true">
    /// Internal dispose function
    /// </summary>
    protected virtual void Dispose(bool disposing)
    {
      if (!disposed)
      {
        disposed= true;

        if (disposing)
        {
          // Free managed resources;
        }

        // Free native resources
      }
    }


    #endregion Finalize

    #region Methods

    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void addBonusText()
    {
      mcr.EvaluateFunction(0, "addBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    ///
    public void addBonusText(MWArray text)
    {
      mcr.EvaluateFunction(0, "addBonusText", text);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    ///
    public void addBonusText(MWArray text, MWArray figHandle)
    {
      mcr.EvaluateFunction(0, "addBonusText", text, figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addBonusText(int numArgsOut, MWArray text)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", text);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the addBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addBonusText(int numArgsOut, MWArray text, MWArray figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addBonusText", text, figHandle);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void addFunctionToPlot()
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void addFunctionToPlot(MWArray traceName)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    ///
    public void addFunctionToPlot(MWArray traceName, MWArray xData)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    ///
    public void addFunctionToPlot(MWArray traceName, MWArray xData, MWArray yData)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData);
    }


    /// <summary>
    /// Provides a void output, 4-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    ///
    public void addFunctionToPlot(MWArray traceName, MWArray xData, MWArray yData, 
                            MWArray colorName)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName);
    }


    /// <summary>
    /// Provides a void output, 5-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    ///
    public void addFunctionToPlot(MWArray traceName, MWArray xData, MWArray yData, 
                            MWArray colorName, MWArray lineWidth)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth);
    }


    /// <summary>
    /// Provides a void output, 6-input MWArrayinterface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <param name="lineStyle">Input argument #6</param>
    ///
    public void addFunctionToPlot(MWArray traceName, MWArray xData, MWArray yData, 
                            MWArray colorName, MWArray lineWidth, MWArray lineStyle)
    {
      mcr.EvaluateFunction(0, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth, lineStyle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName, MWArray xData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName, MWArray xData, 
                                 MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName, MWArray xData, 
                                 MWArray yData, MWArray colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName, MWArray xData, 
                                 MWArray yData, MWArray colorName, MWArray lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the addFunctionToPlot
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <param name="colorName">Input argument #4</param>
    /// <param name="lineWidth">Input argument #5</param>
    /// <param name="lineStyle">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addFunctionToPlot(int numArgsOut, MWArray traceName, MWArray xData, 
                                 MWArray yData, MWArray colorName, MWArray lineWidth, 
                                 MWArray lineStyle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addFunctionToPlot", traceName, xData, yData, colorName, lineWidth, lineStyle);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void addStatusText()
    {
      mcr.EvaluateFunction(0, "addStatusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    ///
    public void addStatusText(MWArray text)
    {
      mcr.EvaluateFunction(0, "addStatusText", text);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    ///
    public void addStatusText(MWArray text, MWArray figHandle)
    {
      mcr.EvaluateFunction(0, "addStatusText", text, figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addStatusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addStatusText(int numArgsOut, MWArray text)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", text);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the addStatusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this adds text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="text">Input argument #1</param>
    /// <param name="figHandle">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addStatusText(int numArgsOut, MWArray text, MWArray figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "addStatusText", text, figHandle);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray addTrace()
    {
      return mcr.EvaluateFunction("addTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray addTrace(MWArray newData)
    {
      return mcr.EvaluateFunction("addTrace", newData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray addTrace(MWArray newData, MWArray channelName)
    {
      return mcr.EvaluateFunction("addTrace", newData, channelName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addTrace(int numArgsOut, MWArray newData)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", newData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the addTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] addTrace(int numArgsOut, MWArray newData, MWArray channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "addTrace", newData, channelName);
    }


    /// <summary>
    /// Provides an interface for the addTrace function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void addTrace(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("addTrace", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the analysisAxis
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray analysisAxis()
    {
      return mcr.EvaluateFunction("analysisAxis", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the analysisAxis
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="plotName">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray analysisAxis(MWArray plotName)
    {
      return mcr.EvaluateFunction("analysisAxis", plotName);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the analysisAxis
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="plotName">Input argument #1</param>
    /// <param name="axisHandle_in1">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray analysisAxis(MWArray plotName, MWArray axisHandle_in1)
    {
      return mcr.EvaluateFunction("analysisAxis", plotName, axisHandle_in1);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] analysisAxis(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="plotName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] analysisAxis(int numArgsOut, MWArray plotName)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", plotName);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the analysisAxis M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="plotName">Input argument #1</param>
    /// <param name="axisHandle_in1">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] analysisAxis(int numArgsOut, MWArray plotName, MWArray 
                            axisHandle_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "analysisAxis", plotName, axisHandle_in1);
    }


    /// <summary>
    /// Provides an interface for the analysisAxis function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// called by other functions to add an analysis axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void analysisAxis(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("analysisAxis", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apHeight()
    {
      return mcr.EvaluateFunction("apHeight", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apHeight(MWArray inData)
    {
      return mcr.EvaluateFunction("apHeight", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apHeight(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apHeight(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apHeight(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                      MWArray axisHandle)
    {
      return mcr.EvaluateFunction("apHeight", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apHeight(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apHeight(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apHeight(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apHeight(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                        MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the apHeight M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apHeight(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                        MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apHeight", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apHeight function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// spikeHeights = APHeight(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the height (in mV) from the point at which the AP crosses
    /// threshold to the point at the peak of the AP occurs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void apHeight(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("apHeight", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apRiseFallRatio()
    {
      return mcr.EvaluateFunction("apRiseFallRatio", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apRiseFallRatio(MWArray traceData)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apRiseFallRatio(MWArray traceData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apRiseFallRatio(MWArray traceData, MWArray timePerPoint, MWArray 
                             startTime)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apRiseFallRatio(MWArray traceData, MWArray timePerPoint, MWArray 
                             startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction("apRiseFallRatio", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apRiseFallRatio(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apRiseFallRatio(int numArgsOut, MWArray traceData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apRiseFallRatio(int numArgsOut, MWArray traceData, MWArray 
                               timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apRiseFallRatio(int numArgsOut, MWArray traceData, MWArray 
                               timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the apRiseFallRatio
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apRiseFallRatio(int numArgsOut, MWArray traceData, MWArray 
                               timePerPoint, MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apRiseFallRatio", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apRiseFallRatio function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidths = apRiseFallRatio(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void apRiseFallRatio(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("apRiseFallRatio", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apThreshold()
    {
      return mcr.EvaluateFunction("apThreshold", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apThreshold(MWArray inData)
    {
      return mcr.EvaluateFunction("apThreshold", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apThreshold(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apThreshold(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apThreshold(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                         MWArray axisHandle)
    {
      return mcr.EvaluateFunction("apThreshold", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apThreshold(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apThreshold(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apThreshold(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apThreshold(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                           MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the apThreshold M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apThreshold(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                           MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apThreshold", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apThreshold function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// thresholds = APthreshold(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the membrane potential (in mV) where the maximum of the second
    /// derivative in the period immediately before the spike, looking for the
    /// first time that the second derivative has a peak in that period that is
    /// at least 25   of that height, and then searching backward from that peak
    /// to the first time that the second derivative is less than 10   of that
    /// maximum peak
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void apThreshold(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("apThreshold", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidth()
    {
      return mcr.EvaluateFunction("apWidth", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidth(MWArray traceData)
    {
      return mcr.EvaluateFunction("apWidth", traceData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidth(MWArray traceData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidth(MWArray traceData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidth(MWArray traceData, MWArray timePerPoint, MWArray startTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("apWidth", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidth(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidth(int numArgsOut, MWArray traceData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidth(int numArgsOut, MWArray traceData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidth(int numArgsOut, MWArray traceData, MWArray timePerPoint, 
                       MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the apWidth M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidth(int numArgsOut, MWArray traceData, MWArray timePerPoint, 
                       MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidth", traceData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apWidth function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidths = APWidth(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point at which the AP crosses
    /// threshold to the point at which it is passing back by threshold on the
    /// way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void apWidth(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("apWidth", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidthHM()
    {
      return mcr.EvaluateFunction("apWidthHM", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidthHM(MWArray inData)
    {
      return mcr.EvaluateFunction("apWidthHM", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidthHM(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidthHM(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray apWidthHM(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                       MWArray axisHandle)
    {
      return mcr.EvaluateFunction("apWidthHM", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidthHM(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidthHM(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidthHM(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidthHM(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                         MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the apWidthHM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] apWidthHM(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                         MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "apWidthHM", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the apWidthHM function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// apWidthsAtHalfMax = APWidthHM(dataTrace, timerPerPoint, startTime,
    /// outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the time (in ms) from the point vertically half way between
    /// where the AP crosses threshold and the peak to the point at which it is
    /// passing back by this height on the way down
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void apWidthHM(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("apWidthHM", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the autoCorrelate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoCorrelate()
    {
      return mcr.EvaluateFunction("autoCorrelate", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the autoCorrelate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoCorrelate(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("autoCorrelate", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the autoCorrelate M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoCorrelate(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoCorrelate", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the autoCorrelate M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoCorrelate(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoCorrelate", varargin);
    }


    /// <summary>
    /// Provides an interface for the autoCorrelate function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void autoCorrelate(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("autoCorrelate", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoNotch()
    {
      return mcr.EvaluateFunction("autoNotch", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoNotch(MWArray inData)
    {
      return mcr.EvaluateFunction("autoNotch", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoNotch(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoNotch(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray autoNotch(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                       MWArray axisHandle)
    {
      return mcr.EvaluateFunction("autoNotch", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoNotch(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoNotch(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoNotch(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoNotch(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                         MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the autoNotch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] autoNotch(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                         MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "autoNotch", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the autoNotch function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generate a notch filter for a data set
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void autoNotch(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("autoNotch", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray bandStop()
    {
      return mcr.EvaluateFunction("bandStop", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray bandStop(MWArray inData)
    {
      return mcr.EvaluateFunction("bandStop", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray bandStop(MWArray inData, MWArray lowStopBand)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray bandStop(MWArray inData, MWArray lowStopBand, MWArray highStopBand)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand, highStopBand);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <param name="samplingFreq">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray bandStop(MWArray inData, MWArray lowStopBand, MWArray highStopBand, 
                      MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("bandStop", inData, lowStopBand, highStopBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] bandStop(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] bandStop(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] bandStop(int numArgsOut, MWArray inData, MWArray lowStopBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] bandStop(int numArgsOut, MWArray inData, MWArray lowStopBand, 
                        MWArray highStopBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand, highStopBand);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the bandStop M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="lowStopBand">Input argument #2</param>
    /// <param name="highStopBand">Input argument #3</param>
    /// <param name="samplingFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] bandStop(int numArgsOut, MWArray inData, MWArray lowStopBand, 
                        MWArray highStopBand, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "bandStop", inData, lowStopBand, highStopBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the bandStop function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// band stop filter data
    /// filteredData = bandStop(rawData, [lowStopBandLowerLimit lowStopBandUpperLimit],
    /// [highStopBandLowerLimit highStopBandUpperLimit], samplingFrequency)
    /// defaults:
    /// lowStopBand = [50 100] Hz
    /// highStopBand = [1000 2000] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void bandStop(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("bandStop", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benConv()
    {
      return mcr.EvaluateFunction("benConv", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="inTrace">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benConv(MWArray inTrace)
    {
      return mcr.EvaluateFunction("benConv", inTrace);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="inTrace">Input argument #1</param>
    /// <param name="kernel">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benConv(MWArray inTrace, MWArray kernel)
    {
      return mcr.EvaluateFunction("benConv", inTrace, kernel);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benConv(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inTrace">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benConv(int numArgsOut, MWArray inTrace)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", inTrace);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benConv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inTrace">Input argument #1</param>
    /// <param name="kernel">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benConv(int numArgsOut, MWArray inTrace, MWArray kernel)
    {
      return mcr.EvaluateFunction(numArgsOut, "benConv", inTrace, kernel);
    }


    /// <summary>
    /// Provides an interface for the benConv function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this does convolution and forces outTrace size to match inTrace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benConv(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benConv", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benDisplayString()
    {
      return mcr.EvaluateFunction("benDisplayString", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="inNum">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benDisplayString(MWArray inNum)
    {
      return mcr.EvaluateFunction("benDisplayString", inNum);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benDisplayString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benDisplayString", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benDisplayString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inNum">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benDisplayString(int numArgsOut, MWArray inNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "benDisplayString", inNum);
    }


    /// <summary>
    /// Provides an interface for the benDisplayString function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this routine processes a double for proper display on Scope form
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benDisplayString(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benDisplayString", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents()
    {
      return mcr.EvaluateFunction("benEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData)
    {
      return mcr.EvaluateFunction("benEvents", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData, MWArray downEvents)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData, MWArray downEvents, MWArray MsPerPoint)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData, MWArray downEvents, MWArray MsPerPoint, 
                       MWArray startTime)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData, MWArray downEvents, MWArray MsPerPoint, 
                       MWArray startTime, MWArray endTime)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides a single output, 6-input MWArrayinterface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEvents(MWArray inData, MWArray downEvents, MWArray MsPerPoint, 
                       MWArray startTime, MWArray endTime, MWArray parmList)
    {
      return mcr.EvaluateFunction("benEvents", inData, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData, MWArray downEvents)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData, MWArray downEvents, 
                         MWArray MsPerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData, MWArray downEvents, 
                         MWArray MsPerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData, MWArray downEvents, 
                         MWArray MsPerPoint, MWArray startTime, MWArray endTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the benEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEvents(int numArgsOut, MWArray inData, MWArray downEvents, 
                         MWArray MsPerPoint, MWArray startTime, MWArray endTime, MWArray 
                         parmList)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEvents", inData, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides an interface for the benEvents function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// benEvents   4/23/10 last changed to bail out on slope calc if either
    /// Index20 or Index80 is still -1 after search
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benEvents(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benEvents", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld()
    {
      return mcr.EvaluateFunction("benEventsOld", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data)
    {
      return mcr.EvaluateFunction("benEventsOld", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data, MWArray downEvents)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data, MWArray downEvents, MWArray MsPerPoint)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data, MWArray downEvents, MWArray MsPerPoint, 
                          MWArray startTime)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data, MWArray downEvents, MWArray MsPerPoint, 
                          MWArray startTime, MWArray endTime)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides a single output, 6-input MWArrayinterface to the benEventsOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benEventsOld(MWArray data, MWArray downEvents, MWArray MsPerPoint, 
                          MWArray startTime, MWArray endTime, MWArray parmList)
    {
      return mcr.EvaluateFunction("benEventsOld", data, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data, MWArray downEvents)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data, MWArray downEvents, 
                            MWArray MsPerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data, MWArray downEvents, 
                            MWArray MsPerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data, MWArray downEvents, 
                            MWArray MsPerPoint, MWArray startTime, MWArray endTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime, endTime);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the benEventsOld M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="downEvents">Input argument #2</param>
    /// <param name="MsPerPoint">Input argument #3</param>
    /// <param name="startTime">Input argument #4</param>
    /// <param name="endTime">Input argument #5</param>
    /// <param name="parmList">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benEventsOld(int numArgsOut, MWArray data, MWArray downEvents, 
                            MWArray MsPerPoint, MWArray startTime, MWArray endTime, 
                            MWArray parmList)
    {
      return mcr.EvaluateFunction(numArgsOut, "benEventsOld", data, downEvents, MsPerPoint, startTime, endTime, parmList);
    }


    /// <summary>
    /// Provides an interface for the benEventsOld function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// benEvents   9/5/09
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benEventsOld(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benEventsOld", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitLine()
    {
      return mcr.EvaluateFunction("BenFitLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitLine(MWArray yData)
    {
      return mcr.EvaluateFunction("BenFitLine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitLine(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("BenFitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitLine(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the BenFitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitLine(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides an interface for the BenFitLine function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void BenFitLine(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("BenFitLine", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitPolynomial()
    {
      return mcr.EvaluateFunction("BenFitPolynomial", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitPolynomial(MWArray yData)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitPolynomial(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenFitPolynomial(MWArray yData, MWArray timePerPoint, MWArray 
                              PolyOrder)
    {
      return mcr.EvaluateFunction("BenFitPolynomial", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitPolynomial(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitPolynomial(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitPolynomial(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the BenFitPolynomial
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenFitPolynomial(int numArgsOut, MWArray yData, MWArray 
                                timePerPoint, MWArray PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenFitPolynomial", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides an interface for the BenFitPolynomial function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void BenFitPolynomial(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("BenFitPolynomial", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benGenerateStim()
    {
      return mcr.EvaluateFunction("benGenerateStim", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benGenerateStim(MWArray zData)
    {
      return mcr.EvaluateFunction("benGenerateStim", zData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <param name="chanNum">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benGenerateStim(MWArray zData, MWArray chanNum)
    {
      return mcr.EvaluateFunction("benGenerateStim", zData, chanNum);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benGenerateStim(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benGenerateStim(int numArgsOut, MWArray zData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", zData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benGenerateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <param name="chanNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benGenerateStim(int numArgsOut, MWArray zData, MWArray chanNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "benGenerateStim", zData, chanNum);
    }


    /// <summary>
    /// Provides an interface for the benGenerateStim function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// goes through DAC data array and makes fake stim
    /// last revised 29 Jan 2012 BWS
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benGenerateStim(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benGenerateStim", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benPeakAllPoints()
    {
      return mcr.EvaluateFunction("benPeakAllPoints", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benPeakAllPoints(MWArray inData)
    {
      return mcr.EvaluateFunction("benPeakAllPoints", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benPeakAllPoints(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPoints", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benPeakAllPoints
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benPeakAllPoints(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPoints", inData);
    }


    /// <summary>
    /// Provides an interface for the benPeakAllPoints function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benPeakAllPoints(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benPeakAllPoints", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benPeakAllPointsTenths()
    {
      return mcr.EvaluateFunction("benPeakAllPointsTenths", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benPeakAllPointsTenths(MWArray inData)
    {
      return mcr.EvaluateFunction("benPeakAllPointsTenths", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benPeakAllPointsTenths(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPointsTenths", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benPeakAllPointsTenths
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benPeakAllPointsTenths(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "benPeakAllPointsTenths", inData);
    }


    /// <summary>
    /// Provides an interface for the benPeakAllPointsTenths function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function returns the integer value that represents the peak of the
    /// all points histogram of the data array
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benPeakAllPointsTenths(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                             argsIn)
    {
      mcr.EvaluateFunction("benPeakAllPointsTenths", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    ///
    public void benProtocolViewer()
    {
      mcr.EvaluateFunction(0, "benProtocolViewer", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="fileName">Input argument #1</param>
    ///
    public void benProtocolViewer(MWArray fileName)
    {
      mcr.EvaluateFunction(0, "benProtocolViewer", fileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benProtocolViewer(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benProtocolViewer", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benProtocolViewer
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// loadProtocol(fileName);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="fileName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benProtocolViewer(int numArgsOut, MWArray fileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "benProtocolViewer", fileName);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats1Array()
    {
      return mcr.EvaluateFunction("benStats1Array", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats1Array(MWArray inArray1)
    {
      return mcr.EvaluateFunction("benStats1Array", inArray1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benStats1Array
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="testValue">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats1Array(MWArray inArray1, MWArray testValue)
    {
      return mcr.EvaluateFunction("benStats1Array", inArray1, testValue);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats1Array(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats1Array(int numArgsOut, MWArray inArray1)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", inArray1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benStats1Array M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="testValue">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats1Array(int numArgsOut, MWArray inArray1, MWArray testValue)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats1Array", inArray1, testValue);
    }


    /// <summary>
    /// Provides an interface for the benStats1Array function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benStats1Array(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benStats1Array", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats2Arrays()
    {
      return mcr.EvaluateFunction("benStats2Arrays", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats2Arrays(MWArray inArray1)
    {
      return mcr.EvaluateFunction("benStats2Arrays", inArray1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray benStats2Arrays(MWArray inArray1, MWArray inArray2)
    {
      return mcr.EvaluateFunction("benStats2Arrays", inArray1, inArray2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats2Arrays(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats2Arrays(int numArgsOut, MWArray inArray1)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", inArray1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the benStats2Arrays
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray1">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] benStats2Arrays(int numArgsOut, MWArray inArray1, MWArray inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "benStats2Arrays", inArray1, inArray2);
    }


    /// <summary>
    /// Provides an interface for the benStats2Arrays function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void benStats2Arrays(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("benStats2Arrays", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenVectorMedian()
    {
      return mcr.EvaluateFunction("BenVectorMedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenVectorMedian(MWArray inArray)
    {
      return mcr.EvaluateFunction("BenVectorMedian", inArray);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenVectorMedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenVectorMedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the BenVectorMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenVectorMedian(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenVectorMedian", inArray);
    }


    /// <summary>
    /// Provides an interface for the BenVectorMedian function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void BenVectorMedian(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("BenVectorMedian", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapPolyFit()
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapPolyFit(MWArray yData)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapPolyFit(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the BenWrapPolyFit
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapPolyFit(MWArray yData, MWArray timePerPoint, MWArray PolyOrder)
    {
      return mcr.EvaluateFunction("BenWrapPolyFit", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapPolyFit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapPolyFit(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapPolyFit(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the BenWrapPolyFit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="PolyOrder">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapPolyFit(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                              MWArray PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapPolyFit", yData, timePerPoint, PolyOrder);
    }


    /// <summary>
    /// Provides an interface for the BenWrapPolyFit function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void BenWrapPolyFit(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("BenWrapPolyFit", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapSGolayFilt()
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapSGolayFilt(MWArray InVector)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapSGolayFilt(MWArray InVector, MWArray PolyOrder)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray BenWrapSGolayFilt(MWArray InVector, MWArray PolyOrder, MWArray 
                               FrameSize)
    {
      return mcr.EvaluateFunction("BenWrapSGolayFilt", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapSGolayFilt(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapSGolayFilt(int numArgsOut, MWArray InVector)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapSGolayFilt(int numArgsOut, MWArray InVector, MWArray 
                                 PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the BenWrapSGolayFilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] BenWrapSGolayFilt(int numArgsOut, MWArray InVector, MWArray 
                                 PolyOrder, MWArray FrameSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "BenWrapSGolayFilt", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides an interface for the BenWrapSGolayFilt function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void BenWrapSGolayFilt(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("BenWrapSGolayFilt", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the besselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray besselFilter()
    {
      return mcr.EvaluateFunction("besselFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the besselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray besselFilter(MWArray inData)
    {
      return mcr.EvaluateFunction("besselFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the besselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray besselFilter(MWArray inData, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the besselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray besselFilter(MWArray inData, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the besselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <param name="cutOff">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray besselFilter(MWArray inData, MWArray samplingFreq, MWArray order, 
                          MWArray cutOff)
    {
      return mcr.EvaluateFunction("besselFilter", inData, samplingFreq, order, cutOff);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] besselFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] besselFilter(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] besselFilter(int numArgsOut, MWArray inData, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] besselFilter(int numArgsOut, MWArray inData, MWArray samplingFreq, 
                            MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the besselFilter M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="order">Input argument #3</param>
    /// <param name="cutOff">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] besselFilter(int numArgsOut, MWArray inData, MWArray samplingFreq, 
                            MWArray order, MWArray cutOff)
    {
      return mcr.EvaluateFunction(numArgsOut, "besselFilter", inData, samplingFreq, order, cutOff);
    }


    /// <summary>
    /// Provides an interface for the besselFilter function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void besselFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("besselFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithConstant()
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithConstant(MWArray inData)
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithConstant(MWArray inData, MWArray thresh)
    {
      return mcr.EvaluateFunction("blankAPsWithConstant", inData, thresh);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithConstant(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithConstant(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the blankAPsWithConstant
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithConstant(int numArgsOut, MWArray inData, MWArray thresh)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithConstant", inData, thresh);
    }


    /// <summary>
    /// Provides an interface for the blankAPsWithConstant function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void blankAPsWithConstant(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                           argsIn)
    {
      mcr.EvaluateFunction("blankAPsWithConstant", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithNaNs()
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithNaNs(MWArray inData)
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray blankAPsWithNaNs(MWArray inData, MWArray thresh)
    {
      return mcr.EvaluateFunction("blankAPsWithNaNs", inData, thresh);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithNaNs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithNaNs(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the blankAPsWithNaNs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="thresh">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] blankAPsWithNaNs(int numArgsOut, MWArray inData, MWArray thresh)
    {
      return mcr.EvaluateFunction(numArgsOut, "blankAPsWithNaNs", inData, thresh);
    }


    /// <summary>
    /// Provides an interface for the blankAPsWithNaNs function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void blankAPsWithNaNs(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("blankAPsWithNaNs", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray burstingProbability()
    {
      return mcr.EvaluateFunction("burstingProbability", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray burstingProbability(MWArray inData)
    {
      return mcr.EvaluateFunction("burstingProbability", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray burstingProbability(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("burstingProbability", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="threshTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray burstingProbability(MWArray inData, MWArray timePerPoint, MWArray 
                                 threshTime)
    {
      return mcr.EvaluateFunction("burstingProbability", inData, timePerPoint, threshTime);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] burstingProbability(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] burstingProbability(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] burstingProbability(int numArgsOut, MWArray inData, MWArray 
                                   timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the burstingProbability
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="threshTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] burstingProbability(int numArgsOut, MWArray inData, MWArray 
                                   timePerPoint, MWArray threshTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "burstingProbability", inData, timePerPoint, threshTime);
    }


    /// <summary>
    /// Provides an interface for the burstingProbability function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// pValue = burstingProbability(traceData, threshTime);
    /// pValue = burstingProbability(eventTimes, threshTime);
    /// defaults:
    /// threshTime = mean(interevent_interval);
    /// use the joint distribution (left-handed interevent interval vs right-
    /// handed interevent interval) to determine whether the events are bursty,
    /// as defined by more events with one of their nearest neighbors closer by
    /// in time than an evenly-spaced event distribution would assume
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void burstingProbability(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                          argsIn)
    {
      mcr.EvaluateFunction("burstingProbability", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the calcBurstProb
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcBurstProb()
    {
      return mcr.EvaluateFunction("calcBurstProb", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the calcBurstProb
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcBurstProb(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("calcBurstProb", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the calcBurstProb M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcBurstProb(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcBurstProb", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the calcBurstProb M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcBurstProb(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcBurstProb", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcBurstProb function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void calcBurstProb(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("calcBurstProb", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcMean()
    {
      return mcr.EvaluateFunction("calcMean", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcMean(MWArray inData)
    {
      return mcr.EvaluateFunction("calcMean", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcMean(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcMean", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the calcMean M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcMean(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcMean", inData);
    }


    /// <summary>
    /// Provides an interface for the calcMean function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// find the greatest value of the all points histogram
    /// meanValue = calcMean(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void calcMean(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("calcMean", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcSTA()
    {
      return mcr.EvaluateFunction("calcSTA", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcSTA(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("calcSTA", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcSTA(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTA", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the calcSTA M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcSTA(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTA", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcSTA function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void calcSTA(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("calcSTA", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcSTO()
    {
      return mcr.EvaluateFunction("calcSTO", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray calcSTO(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("calcSTO", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcSTO(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTO", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the calcSTO M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] calcSTO(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "calcSTO", varargin);
    }


    /// <summary>
    /// Provides an interface for the calcSTO function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void calcSTO(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("calcSTO", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray cell2mat()
    {
      return mcr.EvaluateFunction("cell2mat", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="c">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray cell2mat(MWArray c)
    {
      return mcr.EvaluateFunction("cell2mat", c);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] cell2mat(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "cell2mat", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the cell2mat M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="c">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] cell2mat(int numArgsOut, MWArray c)
    {
      return mcr.EvaluateFunction(numArgsOut, "cell2mat", c);
    }


    /// <summary>
    /// Provides an interface for the cell2mat function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// CELL2MAT Convert the contents of a cell array into a single matrix.
    /// M = CELL2MAT(C) converts a multidimensional cell array with contents of
    /// the same data type into a single matrix. The contents of C must be able
    /// to concatenate into a hyperrectangle. Moreover, for each pair of
    /// neighboring cells, the dimensions of the cell's contents must match,
    /// excluding the dimension in which the cells are neighbors. This constraint
    /// must hold true for neighboring cells along all of the cell array's
    /// dimensions.
    /// The dimensionality of M, i.e. the number of dimensions of M, will match
    /// the highest dimensionality contained in the cell array.
    /// CELL2MAT is not supported for cell arrays containing cell arrays or
    /// objects.
    /// Example:
    /// C = {[1] [2 3 4]; [5; 9] [6 7 8; 10 11 12]};
    /// M = cell2mat(C)
    /// See also MAT2CELL, NUM2CELL
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void cell2mat(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("cell2mat", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray characterizePSPs()
    {
      return mcr.EvaluateFunction("characterizePSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="PSPs">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray characterizePSPs(MWArray PSPs)
    {
      return mcr.EvaluateFunction("characterizePSPs", PSPs);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="PSPs">Input argument #1</param>
    /// <param name="totalTime">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray characterizePSPs(MWArray PSPs, MWArray totalTime)
    {
      return mcr.EvaluateFunction("characterizePSPs", PSPs, totalTime);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] characterizePSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="PSPs">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] characterizePSPs(int numArgsOut, MWArray PSPs)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", PSPs);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the characterizePSPs
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="PSPs">Input argument #1</param>
    /// <param name="totalTime">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] characterizePSPs(int numArgsOut, MWArray PSPs, MWArray totalTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "characterizePSPs", PSPs, totalTime);
    }


    /// <summary>
    /// Provides an interface for the characterizePSPs function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// sort into I and E PSPs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void characterizePSPs(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("characterizePSPs", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the clearBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    ///
    public void clearBonusText()
    {
      mcr.EvaluateFunction(0, "clearBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the clearBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    ///
    public void clearBonusText(MWArray figHandle)
    {
      mcr.EvaluateFunction(0, "clearBonusText", figHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] clearBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the clearBonusText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this clears text to the top line of the Scope window
    /// figHandle is optional, if not supplied text added to all scope windows
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] clearBonusText(int numArgsOut, MWArray figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearBonusText", figHandle);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the clearExtraLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void clearExtraLines()
    {
      mcr.EvaluateFunction(0, "clearExtraLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the clearExtraLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] clearExtraLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "clearExtraLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray colorSpread()
    {
      return mcr.EvaluateFunction("colorSpread", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray colorSpread(MWArray m)
    {
      return mcr.EvaluateFunction("colorSpread", m);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] colorSpread(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "colorSpread", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the colorSpread M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] colorSpread(int numArgsOut, MWArray m)
    {
      return mcr.EvaluateFunction(numArgsOut, "colorSpread", m);
    }


    /// <summary>
    /// Provides an interface for the colorSpread function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// COLORCUBE Enhanced color-cube color map.
    /// COLORCUBE(M) returns an M-by-3 matrix containing a colorcube.
    /// COLORCUBE, by itself, is the same length as the current colormap.
    /// The colorcube contains as many regularly spaced colors in RGB
    /// colorspace as possible, while attempting to provide more steps
    /// of gray, pure red, pure green, and pure blue.
    /// The algorithm for this cube was inspired by the default
    /// Macintosh system colortable, and for M = 256, COLORCUBE returns
    /// exactly the same colors.  For M &lt; 8, a gray ramp of length M
    /// is returned.
    /// See also COLORMAP, RGBPLOT.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void colorSpread(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("colorSpread", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray combFilter()
    {
      return mcr.EvaluateFunction("combFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray combFilter(MWArray inData)
    {
      return mcr.EvaluateFunction("combFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray combFilter(MWArray inData, MWArray selectedFrequencies)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray combFilter(MWArray inData, MWArray selectedFrequencies, MWArray 
                        samplingFreq)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <param name="whichPart">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray combFilter(MWArray inData, MWArray selectedFrequencies, MWArray 
                        samplingFreq, MWArray whichPart)
    {
      return mcr.EvaluateFunction("combFilter", inData, selectedFrequencies, samplingFreq, whichPart);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] combFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] combFilter(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] combFilter(int numArgsOut, MWArray inData, MWArray 
                          selectedFrequencies)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] combFilter(int numArgsOut, MWArray inData, MWArray 
                          selectedFrequencies, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the combFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="selectedFrequencies">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <param name="whichPart">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] combFilter(int numArgsOut, MWArray inData, MWArray 
                          selectedFrequencies, MWArray samplingFreq, MWArray whichPart)
    {
      return mcr.EvaluateFunction(numArgsOut, "combFilter", inData, selectedFrequencies, samplingFreq, whichPart);
    }


    /// <summary>
    /// Provides an interface for the combFilter function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// remove sinusoidal noise at selectedFrequencies by finding the phase and
    /// amplitude of the signal at those frequencies and subtracting a
    /// complementary sine wave
    /// outData = combFilter(inData, selectedFrequencies, samplingFreq, whichPart)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void combFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("combFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the commonEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray commonEvents()
    {
      return mcr.EvaluateFunction("commonEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the commonEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray commonEvents(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("commonEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] commonEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "commonEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the commonEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] commonEvents(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "commonEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the commonEvents function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// outData = allCoincidents;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void commonEvents(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("commonEvents", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the Contents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void Contents()
    {
      mcr.EvaluateFunction(0, "Contents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the Contents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] Contents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "Contents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crossCorr()
    {
      return mcr.EvaluateFunction("crossCorr", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crossCorr(MWArray data)
    {
      return mcr.EvaluateFunction("crossCorr", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crossCorr(MWArray data, MWArray corrVals)
    {
      return mcr.EvaluateFunction("crossCorr", data, corrVals);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <param name="coincidenceInterval">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crossCorr(MWArray data, MWArray corrVals, MWArray coincidenceInterval)
    {
      return mcr.EvaluateFunction("crossCorr", data, corrVals, coincidenceInterval);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crossCorr(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crossCorr(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crossCorr(int numArgsOut, MWArray data, MWArray corrVals)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data, corrVals);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the crossCorr M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="corrVals">Input argument #2</param>
    /// <param name="coincidenceInterval">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crossCorr(int numArgsOut, MWArray data, MWArray corrVals, MWArray 
                         coincidenceInterval)
    {
      return mcr.EvaluateFunction(numArgsOut, "crossCorr", data, corrVals, coincidenceInterval);
    }


    /// <summary>
    /// Provides an interface for the crossCorr function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// determine if we're doing an autocorrelogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void crossCorr(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("crossCorr", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crosscorrelateSetup()
    {
      return mcr.EvaluateFunction("crosscorrelateSetup", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray crosscorrelateSetup(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("crosscorrelateSetup", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crosscorrelateSetup(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "crosscorrelateSetup", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the crosscorrelateSetup
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] crosscorrelateSetup(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "crosscorrelateSetup", varargin);
    }


    /// <summary>
    /// Provides an interface for the crosscorrelateSetup function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// from events 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void crosscorrelateSetup(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                          argsIn)
    {
      mcr.EvaluateFunction("crosscorrelateSetup", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectAPs()
    {
      return mcr.EvaluateFunction("detectAPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectAPs(MWArray data)
    {
      return mcr.EvaluateFunction("detectAPs", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectAPs(MWArray data, MWArray protocol)
    {
      return mcr.EvaluateFunction("detectAPs", data, protocol);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectAPs(MWArray data, MWArray protocol, params MWArray[] varargin)
    {
      MWArray[] args = {data, protocol};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction("detectAPs", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectAPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectAPs(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectAPs(int numArgsOut, MWArray data, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectAPs", data, protocol);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the detectAPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectAPs(int numArgsOut, MWArray data, MWArray protocol, params 
                         MWArray[] varargin)
    {
      MWArray[] args = {data, protocol};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction(numArgsOut, "detectAPs", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides an interface for the detectAPs function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Ben routine to find APs in current clamp record
    /// Inputs  data, protocol, (AP threshold in mV), ([beginTimeMs, endTimeMs])
    /// Output is a list of AP times in ms or []
    /// this routine takes one current clamp record and returns the times of each
    /// AP in trace
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void detectAPs(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("detectAPs", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs()
    {
      return mcr.EvaluateFunction("detectPSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs(MWArray data)
    {
      return mcr.EvaluateFunction("detectPSPs", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs(MWArray data, params MWArray[] varargin)
    {
      MWArray[] args = {data};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction("detectPSPs", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the detectPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs(int numArgsOut, MWArray data, params MWArray[] varargin)
    {
      MWArray[] args = {data};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction(numArgsOut, "detectPSPs", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides an interface for the detectPSPs function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Parse through the inputs
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void detectPSPs(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("detectPSPs", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the detectPSPs3d
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs3d()
    {
      return mcr.EvaluateFunction("detectPSPs3d", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the detectPSPs3d
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs3d(MWArray data)
    {
      return mcr.EvaluateFunction("detectPSPs3d", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the detectPSPs3d
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectPSPs3d(MWArray data, MWArray protocol)
    {
      return mcr.EvaluateFunction("detectPSPs3d", data, protocol);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs3d(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs3d(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the detectPSPs3d M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="protocol">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectPSPs3d(int numArgsOut, MWArray data, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectPSPs3d", data, protocol);
    }


    /// <summary>
    /// Provides an interface for the detectPSPs3d function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this is a subfunction, so gets access to outside variables  
    /// 3d version made to remove pump noise on 8.6.08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void detectPSPs3d(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("detectPSPs3d", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the detectSpikes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectSpikes()
    {
      return mcr.EvaluateFunction("detectSpikes", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the detectSpikes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectSpikes(MWArray inData)
    {
      return mcr.EvaluateFunction("detectSpikes", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the detectSpikes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectSpikes(MWArray inData, MWArray spikeHeight)
    {
      return mcr.EvaluateFunction("detectSpikes", inData, spikeHeight);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the detectSpikes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <param name="whereCall">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray detectSpikes(MWArray inData, MWArray spikeHeight, MWArray whereCall)
    {
      return mcr.EvaluateFunction("detectSpikes", inData, spikeHeight, whereCall);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectSpikes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectSpikes(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectSpikes(int numArgsOut, MWArray inData, MWArray spikeHeight)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData, spikeHeight);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the detectSpikes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="spikeHeight">Input argument #2</param>
    /// <param name="whereCall">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] detectSpikes(int numArgsOut, MWArray inData, MWArray spikeHeight, 
                            MWArray whereCall)
    {
      return mcr.EvaluateFunction(numArgsOut, "detectSpikes", inData, spikeHeight, whereCall);
    }


    /// <summary>
    /// Provides an interface for the detectSpikes function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// spikes = detectSpikes(inData, spikeHeight, whereCall)
    /// whereCall determines what is returned for spike locations
    /// whereCall = 1 => AP threshold
    /// whereCall = 2 => time midpoint of peak and threshold
    /// whereCall = 3 => height midpoint of peak and threshold (default)
    /// whereCall = 4 => peak
    /// whereCall = 5 => sloppy peak
    /// spikeHeight not specified => 25 mV above baseline
    /// the results are filtered such that spikes with a frequency of greater
    /// than one per every 10 samples will be rejected
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void detectSpikes(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("detectSpikes", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void displayEventLines()
    {
      mcr.EvaluateFunction(0, "displayEventLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    ///
    public void displayEventLines(MWArray channelName)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    ///
    public void displayEventLines(MWArray channelName, MWArray baselineValue)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    ///
    public void displayEventLines(MWArray channelName, MWArray baselineValue, MWArray 
                            eventTimes)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes);
    }


    /// <summary>
    /// Provides a void output, 4-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    ///
    public void displayEventLines(MWArray channelName, MWArray baselineValue, MWArray 
                            eventTimes, MWArray eventAmps)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps);
    }


    /// <summary>
    /// Provides a void output, 5-input MWArrayinterface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <param name="eventColors">Input argument #5</param>
    ///
    public void displayEventLines(MWArray channelName, MWArray baselineValue, MWArray 
                            eventTimes, MWArray eventAmps, MWArray eventColors)
    {
      mcr.EvaluateFunction(0, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps, eventColors);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut, MWArray channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut, MWArray channelName, MWArray 
                                 baselineValue)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut, MWArray channelName, MWArray 
                                 baselineValue, MWArray eventTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut, MWArray channelName, MWArray 
                                 baselineValue, MWArray eventTimes, MWArray eventAmps)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the displayEventLines
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <param name="baselineValue">Input argument #2</param>
    /// <param name="eventTimes">Input argument #3</param>
    /// <param name="eventAmps">Input argument #4</param>
    /// <param name="eventColors">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLines(int numArgsOut, MWArray channelName, MWArray 
                                 baselineValue, MWArray eventTimes, MWArray eventAmps, 
                                 MWArray eventColors)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLines", channelName, baselineValue, eventTimes, eventAmps, eventColors);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray displayEventLinesSimple()
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray displayEventLinesSimple(MWArray eventTimes)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray displayEventLinesSimple(MWArray eventTimes, MWArray lineMin)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes, lineMin);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <param name="lineMax">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray displayEventLinesSimple(MWArray eventTimes, MWArray lineMin, MWArray 
                                     lineMax)
    {
      return mcr.EvaluateFunction("displayEventLinesSimple", eventTimes, lineMin, lineMax);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLinesSimple(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLinesSimple(int numArgsOut, MWArray eventTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLinesSimple(int numArgsOut, MWArray eventTimes, MWArray 
                                       lineMin)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes, lineMin);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the displayEventLinesSimple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="eventTimes">Input argument #1</param>
    /// <param name="lineMin">Input argument #2</param>
    /// <param name="lineMax">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] displayEventLinesSimple(int numArgsOut, MWArray eventTimes, MWArray 
                                       lineMin, MWArray lineMax)
    {
      return mcr.EvaluateFunction(numArgsOut, "displayEventLinesSimple", eventTimes, lineMin, lineMax);
    }


    /// <summary>
    /// Provides an interface for the displayEventLinesSimple function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void displayEventLinesSimple(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                              argsIn)
    {
      mcr.EvaluateFunction("displayEventLinesSimple", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the dumpPreferences
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void dumpPreferences()
    {
      mcr.EvaluateFunction(0, "dumpPreferences", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the dumpPreferences
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] dumpPreferences(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "dumpPreferences", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evaluateBonusText()
    {
      return mcr.EvaluateFunction("evaluateBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evaluateBonusText(MWArray protocol)
    {
      return mcr.EvaluateFunction("evaluateBonusText", protocol);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evaluateBonusText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateBonusText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the evaluateBonusText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evaluateBonusText(int numArgsOut, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateBonusText", protocol);
    }


    /// <summary>
    /// Provides an interface for the evaluateBonusText function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void evaluateBonusText(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("evaluateBonusText", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the evaluateExportText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evaluateExportText()
    {
      return mcr.EvaluateFunction("evaluateExportText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the evaluateExportText
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evaluateExportText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "evaluateExportText", new MWArray[]{});
    }


    /// <summary>
    /// Provides an interface for the evaluateExportText function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// short and long concentrations are the same
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void evaluateExportText(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("evaluateExportText", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage()
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage(MWArray events)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage(MWArray events, MWArray postTrace)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage(MWArray events, MWArray postTrace, MWArray 
                                   window)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage(MWArray events, MWArray postTrace, MWArray 
                                   window, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <param name="showAllTraces">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray eventTriggeredAverage(MWArray events, MWArray postTrace, MWArray 
                                   window, MWArray timePerPoint, MWArray showAllTraces)
    {
      return mcr.EvaluateFunction("eventTriggeredAverage", events, postTrace, window, timePerPoint, showAllTraces);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut, MWArray events)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut, MWArray events, MWArray 
                                     postTrace)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut, MWArray events, MWArray 
                                     postTrace, MWArray window)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut, MWArray events, MWArray 
                                     postTrace, MWArray window, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the eventTriggeredAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="events">Input argument #1</param>
    /// <param name="postTrace">Input argument #2</param>
    /// <param name="window">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <param name="showAllTraces">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] eventTriggeredAverage(int numArgsOut, MWArray events, MWArray 
                                     postTrace, MWArray window, MWArray timePerPoint, 
                                     MWArray showAllTraces)
    {
      return mcr.EvaluateFunction(numArgsOut, "eventTriggeredAverage", events, postTrace, window, timePerPoint, showAllTraces);
    }


    /// <summary>
    /// Provides an interface for the eventTriggeredAverage function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculate the event-triggered average in postTrace using preTrace's spikes
    /// outData = eventTriggeredAverage(events, postTraces, [startTime endTime],
    /// timePerPoint, showAllTraces);
    /// outData = eventTriggeredAverage(tracePaths, [preCell postCell1 postCell 2],
    /// [startTime endTime], timePerPoint, showAllTraces);
    /// defaults:
    /// window = [-10 100] ms
    /// timePerPoint = 0.2 ms
    /// showAllTraces = false
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void eventTriggeredAverage(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                            argsIn)
    {
      mcr.EvaluateFunction("eventTriggeredAverage", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray executeMatlabLine()
    {
      return mcr.EvaluateFunction("executeMatlabLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray executeMatlabLine(MWArray inString)
    {
      return mcr.EvaluateFunction("executeMatlabLine", inString);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] executeMatlabLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "executeMatlabLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the executeMatlabLine
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] executeMatlabLine(int numArgsOut, MWArray inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "executeMatlabLine", inString);
    }


    /// <summary>
    /// Provides an interface for the executeMatlabLine function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void executeMatlabLine(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("executeMatlabLine", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the exportToRDrive
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportToRDrive()
    {
      mcr.EvaluateFunction(0, "exportToRDrive", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the exportToRDrive
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportToRDrive(MWArray figure)
    {
      mcr.EvaluateFunction(0, "exportToRDrive", figure);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportToRDrive(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportToRDrive", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the exportToRDrive M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportToRDrive(int numArgsOut, MWArray figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportToRDrive", figure);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the exportWithAxes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportWithAxes()
    {
      mcr.EvaluateFunction(0, "exportWithAxes", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the exportWithAxes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportWithAxes(MWArray figure)
    {
      mcr.EvaluateFunction(0, "exportWithAxes", figure);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportWithAxes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithAxes", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the exportWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportWithAxes(int numArgsOut, MWArray figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithAxes", figure);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    ///
    public void exportWithScaleBars()
    {
      mcr.EvaluateFunction(0, "exportWithScaleBars", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void exportWithScaleBars(MWArray figure)
    {
      mcr.EvaluateFunction(0, "exportWithScaleBars", figure);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportWithScaleBars(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithScaleBars", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the exportWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for converting a newScope to an enhanced meta-file on the clipboard
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] exportWithScaleBars(int numArgsOut, MWArray figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "exportWithScaleBars", figure);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHP()
    {
      return mcr.EvaluateFunction("fastAHP", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHP(MWArray inData)
    {
      return mcr.EvaluateFunction("fastAHP", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHP(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHP(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHP(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fastAHP", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHP(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHP(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHP(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHP(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                       MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fastAHP M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHP(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                       MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHP", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fastAHP function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fastAHP(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fastAHP", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fastAHPSlope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHPSlope()
    {
      return mcr.EvaluateFunction("fastAHPSlope", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fastAHPSlope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHPSlope(MWArray inData)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fastAHPSlope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHPSlope(MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fastAHPSlope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHPSlope(MWArray inData, MWArray timePerPoint, MWArray startTime)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fastAHPSlope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fastAHPSlope(MWArray inData, MWArray timePerPoint, MWArray startTime, 
                          MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fastAHPSlope", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHPSlope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHPSlope(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHPSlope(int numArgsOut, MWArray inData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHPSlope(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                            MWArray startTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint, startTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fastAHPSlope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fastAHPSlope(int numArgsOut, MWArray inData, MWArray timePerPoint, 
                            MWArray startTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fastAHPSlope", inData, timePerPoint, startTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fastAHPSlope function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// ahpDepths = fastAHP(dataTrace, timerPerPoint, startTime, outputAxisHandle);
    /// defaults:
    /// timePerPoint = 0.2 ms
    /// startTime = 0 ms
    /// outputAxisHandle is a handle to a new newScope figure
    /// determine the distance (in mV) from spike threshold to the bottom of the
    /// AHP sag of the action potential in a minimally-stimulated cell
    /// After Luebke, Frotscher, and Spruston 1998
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fastAHPSlope(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fastAHPSlope", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fcnMin()
    {
      return mcr.EvaluateFunction("fcnMin", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fcnMin(MWArray inData)
    {
      return mcr.EvaluateFunction("fcnMin", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fcnMin(MWArray inData, MWArray number)
    {
      return mcr.EvaluateFunction("fcnMin", inData, number);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <param name="type">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fcnMin(MWArray inData, MWArray number, MWArray type)
    {
      return mcr.EvaluateFunction("fcnMin", inData, number, type);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fcnMin(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fcnMin(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fcnMin(int numArgsOut, MWArray inData, MWArray number)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData, number);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fcnMin M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="number">Input argument #2</param>
    /// <param name="type">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fcnMin(int numArgsOut, MWArray inData, MWArray number, MWArray type)
    {
      return mcr.EvaluateFunction(numArgsOut, "fcnMin", inData, number, type);
    }


    /// <summary>
    /// Provides an interface for the fcnMin function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// finds the minima of the given input data
    /// second two arguements function like those of the find command
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fcnMin(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fcnMin", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findSteps()
    {
      return mcr.EvaluateFunction("findSteps", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findSteps(MWArray protocol)
    {
      return mcr.EvaluateFunction("findSteps", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findSteps(MWArray protocol, MWArray ampNum)
    {
      return mcr.EvaluateFunction("findSteps", protocol, ampNum);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findSteps(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findSteps(int numArgsOut, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the findSteps M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findSteps(int numArgsOut, MWArray protocol, MWArray ampNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "findSteps", protocol, ampNum);
    }


    /// <summary>
    /// Provides an interface for the findSteps function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// function stepData = findSteps(protocol, ampNum)
    /// stepData is of the form [stepNumber, [changeTime changeAmplitude]]
    /// or if no ampNum is passed then [ampNumber, stepNumber, [changeTime
    /// changeAmplitude]]
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void findSteps(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("findSteps", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findStims()
    {
      return mcr.EvaluateFunction("findStims", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findStims(MWArray protocol)
    {
      return mcr.EvaluateFunction("findStims", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="isIndex">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray findStims(MWArray protocol, MWArray isIndex)
    {
      return mcr.EvaluateFunction("findStims", protocol, isIndex);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findStims(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findStims(int numArgsOut, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the findStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="isIndex">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] findStims(int numArgsOut, MWArray protocol, MWArray isIndex)
    {
      return mcr.EvaluateFunction(numArgsOut, "findStims", protocol, isIndex);
    }


    /// <summary>
    /// Provides an interface for the findStims function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// stimTimes is a cell array of n x 2 matrices where column one is the
    /// start, and column two is the stop time for stimuli
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void findStims(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("findStims", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit1Exp()
    {
      return mcr.EvaluateFunction("fit1Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit1Exp(MWArray yData)
    {
      return mcr.EvaluateFunction("fit1Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit1Exp(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit1Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit1Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fit1Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit1Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit1Exp(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit1Exp(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit1Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fit1Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit1Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit1Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit1Exp function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single exponent to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fit1Exp(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fit1Exp", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit2Exp()
    {
      return mcr.EvaluateFunction("fit2Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit2Exp(MWArray yData)
    {
      return mcr.EvaluateFunction("fit2Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit2Exp(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit2Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit2Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fit2Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit2Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit2Exp(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit2Exp(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit2Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fit2Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit2Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit2Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit2Exp function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits two exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fit2Exp(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fit2Exp", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit3Exp()
    {
      return mcr.EvaluateFunction("fit3Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit3Exp(MWArray yData)
    {
      return mcr.EvaluateFunction("fit3Exp", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit3Exp(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit3Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fit3Exp(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fit3Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit3Exp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit3Exp(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit3Exp(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit3Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fit3Exp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fit3Exp(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fit3Exp", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fit3Exp function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits three exponents to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fit3Exp(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fit3Exp", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitAlpha()
    {
      return mcr.EvaluateFunction("fitAlpha", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitAlpha(MWArray yData)
    {
      return mcr.EvaluateFunction("fitAlpha", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitAlpha(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitAlpha(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitAlpha(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                      MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitAlpha", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitAlpha(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitAlpha(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitAlpha(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitAlpha(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                        MWArray startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitAlpha M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitAlpha(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                        MWArray startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitAlpha", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitAlpha function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single alpha function to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitAlpha(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitAlpha", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann()
    {
      return mcr.EvaluateFunction("fitBoltzmann", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann(MWArray yData)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann(MWArray yData, MWArray timePerPoint, MWArray 
                          startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the fitBoltzmann
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmann(MWArray yData, MWArray timePerPoint, MWArray 
                          startingTime, MWArray axisHandle, MWArray traceName)
    {
      return mcr.EvaluateFunction("fitBoltzmann", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                            MWArray startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                            MWArray startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the fitBoltzmann M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmann(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                            MWArray startingTime, MWArray axisHandle, MWArray traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmann", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides an interface for the fitBoltzmann function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitBoltzmann(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitBoltzmann", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen()
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen(MWArray yData)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen(MWArray yData, MWArray timePerPoint, MWArray 
                             startingTime)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen(MWArray yData, MWArray timePerPoint, MWArray 
                             startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitBoltzmannBen(MWArray yData, MWArray timePerPoint, MWArray 
                             startingTime, MWArray axisHandle, MWArray traceName)
    {
      return mcr.EvaluateFunction("fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                               MWArray startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                               MWArray startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the fitBoltzmannBen
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <param name="traceName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitBoltzmannBen(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                               MWArray startingTime, MWArray axisHandle, MWArray 
                               traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitBoltzmannBen", yData, timePerPoint, startingTime, axisHandle, traceName);
    }


    /// <summary>
    /// Provides an interface for the fitBoltzmannBen function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitBoltzmannBen(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitBoltzmannBen", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayDouble()
    {
      return mcr.EvaluateFunction("fitDecayDouble", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayDouble(MWArray yData)
    {
      return mcr.EvaluateFunction("fitDecayDouble", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitDecayDouble
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayDouble(MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction("fitDecayDouble", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayDouble(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayDouble(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitDecayDouble M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayDouble(int numArgsOut, MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayDouble", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecayDouble function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 FittedCurve estimates] = fitDecayDouble(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitDecayDouble(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitDecayDouble", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecaySingle()
    {
      return mcr.EvaluateFunction("fitDecaySingle", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecaySingle(MWArray yData)
    {
      return mcr.EvaluateFunction("fitDecaySingle", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitDecaySingle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecaySingle(MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction("fitDecaySingle", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecaySingle(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecaySingle(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitDecaySingle M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecaySingle(int numArgsOut, MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecaySingle", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecaySingle function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits tau to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 FittedCurve estimates] = fitDecaySingle(yData, PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitDecaySingle(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitDecaySingle", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayTriple()
    {
      return mcr.EvaluateFunction("fitDecayTriple", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayTriple(MWArray yData)
    {
      return mcr.EvaluateFunction("fitDecayTriple", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitDecayTriple
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitDecayTriple(MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction("fitDecayTriple", yData, PSPtype);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayTriple(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayTriple(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitDecayTriple M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="PSPtype">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitDecayTriple(int numArgsOut, MWArray yData, MWArray PSPtype)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitDecayTriple", yData, PSPtype);
    }


    /// <summary>
    /// Provides an interface for the fitDecayTriple function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits taus to ydata that is slowing in x (only determined by the initial offset)
    /// [decayTau1 decayTau2 decayTau3 FittedCurve estimates] = fitDecayTriple(yData,
    /// PSPtype);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitDecayTriple(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitDecayTriple", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLine()
    {
      return mcr.EvaluateFunction("fitLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLine(MWArray yData)
    {
      return mcr.EvaluateFunction("fitLine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLine(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLine(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLine(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitLine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLine(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLine(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLine(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitLine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLine(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitLine function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitLine(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitLine", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitLineExtra
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLineExtra()
    {
      return mcr.EvaluateFunction("fitLineExtra", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitLineExtra
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLineExtra(MWArray yData)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitLineExtra
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLineExtra(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitLineExtra
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLineExtra(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitLineExtra
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitLineExtra(MWArray yData, MWArray timePerPoint, MWArray 
                          startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitLineExtra", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLineExtra(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLineExtra(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLineExtra(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLineExtra(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                            MWArray startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitLineExtra M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitLineExtra(int numArgsOut, MWArray yData, MWArray timePerPoint, 
                            MWArray startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitLineExtra", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitLineExtra function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits line to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitLineExtra(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitLineExtra", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitSine()
    {
      return mcr.EvaluateFunction("fitSine", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitSine(MWArray yData)
    {
      return mcr.EvaluateFunction("fitSine", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitSine(MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitSine(MWArray yData, MWArray timePerPoint, MWArray startingTime)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fitSine(MWArray yData, MWArray timePerPoint, MWArray startingTime, 
                     MWArray axisHandle)
    {
      return mcr.EvaluateFunction("fitSine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitSine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitSine(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitSine(int numArgsOut, MWArray yData, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitSine(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint, startingTime);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the fitSine M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="timePerPoint">Input argument #2</param>
    /// <param name="startingTime">Input argument #3</param>
    /// <param name="axisHandle">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fitSine(int numArgsOut, MWArray yData, MWArray timePerPoint, MWArray 
                       startingTime, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "fitSine", yData, timePerPoint, startingTime, axisHandle);
    }


    /// <summary>
    /// Provides an interface for the fitSine function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// fits single sine wave to data
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fitSine(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fitSine", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fourier()
    {
      return mcr.EvaluateFunction("fourier", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fourier(MWArray yData)
    {
      return mcr.EvaluateFunction("fourier", yData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fourier(MWArray yData, MWArray fs)
    {
      return mcr.EvaluateFunction("fourier", yData, fs);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <param name="frequencies">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray fourier(MWArray yData, MWArray fs, MWArray frequencies)
    {
      return mcr.EvaluateFunction("fourier", yData, fs, frequencies);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fourier(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fourier(int numArgsOut, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fourier(int numArgsOut, MWArray yData, MWArray fs)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData, fs);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the fourier M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="yData">Input argument #1</param>
    /// <param name="fs">Input argument #2</param>
    /// <param name="frequencies">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] fourier(int numArgsOut, MWArray yData, MWArray fs, MWArray 
                       frequencies)
    {
      return mcr.EvaluateFunction(numArgsOut, "fourier", yData, fs, frequencies);
    }


    /// <summary>
    /// Provides an interface for the fourier function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void fourier(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("fourier", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the generateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray generateStim()
    {
      return mcr.EvaluateFunction("generateStim", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the generateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="protocolData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray generateStim(MWArray protocolData)
    {
      return mcr.EvaluateFunction("generateStim", protocolData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the generateStim
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="protocolData">Input argument #1</param>
    /// <param name="experimentData">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray generateStim(MWArray protocolData, MWArray experimentData)
    {
      return mcr.EvaluateFunction("generateStim", protocolData, experimentData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] generateStim(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocolData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] generateStim(int numArgsOut, MWArray protocolData)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", protocolData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the generateStim M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocolData">Input argument #1</param>
    /// <param name="experimentData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] generateStim(int numArgsOut, MWArray protocolData, MWArray 
                            experimentData)
    {
      return mcr.EvaluateFunction(numArgsOut, "generateStim", protocolData, experimentData);
    }


    /// <summary>
    /// Provides an interface for the generateStim function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generates a stimulus vector that is numPoints by numChannels and starts
    /// with any enabled TTLs and then enabled amps.  Outputs are in pa/mV
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void generateStim(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("generateStim", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the GetFromMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray GetFromMatlab()
    {
      return mcr.EvaluateFunction("GetFromMatlab", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the GetFromMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="oldVarName">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray GetFromMatlab(MWArray oldVarName)
    {
      return mcr.EvaluateFunction("GetFromMatlab", oldVarName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the GetFromMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] GetFromMatlab(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "GetFromMatlab", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the GetFromMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="oldVarName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] GetFromMatlab(int numArgsOut, MWArray oldVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "GetFromMatlab", oldVarName);
    }


    /// <summary>
    /// Provides an interface for the GetFromMatlab function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void GetFromMatlab(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("GetFromMatlab", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the getScopeVersion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray getScopeVersion()
    {
      return mcr.EvaluateFunction("getScopeVersion", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the getScopeVersion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] getScopeVersion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "getScopeVersion", new MWArray[]{});
    }


    /// <summary>
    /// Provides an interface for the getScopeVersion function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void getScopeVersion(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("getScopeVersion", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the getVoltTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray getVoltTrace()
    {
      return mcr.EvaluateFunction("getVoltTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the getVoltTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray getVoltTrace(MWArray zData)
    {
      return mcr.EvaluateFunction("getVoltTrace", zData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the getVoltTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="zData">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray getVoltTrace(MWArray zData, params MWArray[] varargin)
    {
      MWArray[] args = {zData};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction("getVoltTrace", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] getVoltTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] getVoltTrace(int numArgsOut, MWArray zData)
    {
      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", zData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the getVoltTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="zData">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] getVoltTrace(int numArgsOut, MWArray zData, params MWArray[] 
                            varargin)
    {
      MWArray[] args = {zData};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction(numArgsOut, "getVoltTrace", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides an interface for the getVoltTrace function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// [ApTimesinMs] = getVoltTrace(zData, TraceNumberFrom1toxx as optional);
    /// this routine gets the first voltage trace in the episode with no optional
    /// arguments
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void getVoltTrace(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("getVoltTrace", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray highPass()
    {
      return mcr.EvaluateFunction("highPass", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray highPass(MWArray inData)
    {
      return mcr.EvaluateFunction("highPass", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray highPass(MWArray inData, MWArray passBand)
    {
      return mcr.EvaluateFunction("highPass", inData, passBand);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray highPass(MWArray inData, MWArray passBand, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("highPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] highPass(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] highPass(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] highPass(int numArgsOut, MWArray inData, MWArray passBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData, passBand);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the highPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] highPass(int numArgsOut, MWArray inData, MWArray passBand, MWArray 
                        samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "highPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the highPass function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// high pass filter data
    /// filteredData = highPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [150 300] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void highPass(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("highPass", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray histfit()
    {
      return mcr.EvaluateFunction("histfit", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray histfit(MWArray data)
    {
      return mcr.EvaluateFunction("histfit", data);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray histfit(MWArray data, params MWArray[] varargin)
    {
      MWArray[] args = {data};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction("histfit", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] histfit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "histfit", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] histfit(int numArgsOut, MWArray data)
    {
      return mcr.EvaluateFunction(numArgsOut, "histfit", data);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the histfit M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="data">Input argument #1</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 2
    /// through varargin.length+1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] histfit(int numArgsOut, MWArray data, params MWArray[] varargin)
    {
      MWArray[] args = {data};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction(numArgsOut, "histfit", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides an interface for the histfit function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// HISTFIT Histogram with superimposed fitted normal density.
    /// HISTFIT(DATA,NBINS) plots a histogram of the values in the vector DATA.
    /// using NBINS bars in the histogram. With one input argument, NBINS is set 
    /// to the square root of the number of elements in DATA. 
    /// H = HISTFIT(DATA,NBINS) returns a vector of handles to the plotted lines.
    /// H(1) is a handle to the histogram, H(2) is a handle to the density curve.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void histfit(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("histfit", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the intervalHist
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray intervalHist()
    {
      return mcr.EvaluateFunction("intervalHist", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the intervalHist
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray intervalHist(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("intervalHist", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] intervalHist(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "intervalHist", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the intervalHist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] intervalHist(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "intervalHist", varargin);
    }


    /// <summary>
    /// Provides an interface for the intervalHist function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show an interval histogram
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void intervalHist(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("intervalHist", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray isiCv()
    {
      return mcr.EvaluateFunction("isiCv", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray isiCv(MWArray inData)
    {
      return mcr.EvaluateFunction("isiCv", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] isiCv(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCv", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the isiCv M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] isiCv(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCv", inData);
    }


    /// <summary>
    /// Provides an interface for the isiCv function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculates the coefficient of variation for the inter-spike interval
    /// standard deviation
    /// Coefficient_of_Variation =    ------------------
    /// mean
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void isiCv(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("isiCv", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray isiCvEvents()
    {
      return mcr.EvaluateFunction("isiCvEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray isiCvEvents(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("isiCvEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] isiCvEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCvEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the isiCvEvents M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] isiCvEvents(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "isiCvEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the isiCvEvents function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void isiCvEvents(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("isiCvEvents", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray jointDist()
    {
      return mcr.EvaluateFunction("jointDist", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray jointDist(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("jointDist", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] jointDist(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "jointDist", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the jointDist M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] jointDist(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "jointDist", varargin);
    }


    /// <summary>
    /// Provides an interface for the jointDist function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// show a joint distribution
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void jointDist(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("jointDist", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray LorenPowerSpectrum()
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray LorenPowerSpectrum(MWArray inData)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray LorenPowerSpectrum(MWArray inData, MWArray SamplingFreq)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray LorenPowerSpectrum(MWArray inData, MWArray SamplingFreq, MWArray 
                                fftPower)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq, fftPower);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <param name="windowLength">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray LorenPowerSpectrum(MWArray inData, MWArray SamplingFreq, MWArray 
                                fftPower, MWArray windowLength)
    {
      return mcr.EvaluateFunction("LorenPowerSpectrum", inData, SamplingFreq, fftPower, windowLength);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] LorenPowerSpectrum(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] LorenPowerSpectrum(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] LorenPowerSpectrum(int numArgsOut, MWArray inData, MWArray 
                                  SamplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] LorenPowerSpectrum(int numArgsOut, MWArray inData, MWArray 
                                  SamplingFreq, MWArray fftPower)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq, fftPower);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the LorenPowerSpectrum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="SamplingFreq">Input argument #2</param>
    /// <param name="fftPower">Input argument #3</param>
    /// <param name="windowLength">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] LorenPowerSpectrum(int numArgsOut, MWArray inData, MWArray 
                                  SamplingFreq, MWArray fftPower, MWArray windowLength)
    {
      return mcr.EvaluateFunction(numArgsOut, "LorenPowerSpectrum", inData, SamplingFreq, fftPower, windowLength);
    }


    /// <summary>
    /// Provides an interface for the LorenPowerSpectrum function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// nfft=2^nextpow2(length(Data));
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void LorenPowerSpectrum(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("LorenPowerSpectrum", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray lowPass()
    {
      return mcr.EvaluateFunction("lowPass", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray lowPass(MWArray inData)
    {
      return mcr.EvaluateFunction("lowPass", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray lowPass(MWArray inData, MWArray passBand)
    {
      return mcr.EvaluateFunction("lowPass", inData, passBand);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray lowPass(MWArray inData, MWArray passBand, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("lowPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] lowPass(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] lowPass(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] lowPass(int numArgsOut, MWArray inData, MWArray passBand)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData, passBand);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the lowPass M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="passBand">Input argument #2</param>
    /// <param name="samplingFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] lowPass(int numArgsOut, MWArray inData, MWArray passBand, MWArray 
                       samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "lowPass", inData, passBand, samplingFreq);
    }


    /// <summary>
    /// Provides an interface for the lowPass function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// low pass filter data
    /// filteredData = lowPass(rawData, [passBandLowerLimit passBandUpperLimit],
    /// samplingFrequency)
    /// defaults:
    /// passBand = [0.0001 150] Hz
    /// samplingFrequency = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void lowPass(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("lowPass", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeBesselFilter()
    {
      return mcr.EvaluateFunction("makeBesselFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeBesselFilter(MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeBesselFilter(MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeBesselFilter(MWArray samplingFreq, MWArray order, MWArray 
                              cutOffFreq)
    {
      return mcr.EvaluateFunction("makeBesselFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeBesselFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeBesselFilter(int numArgsOut, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeBesselFilter(int numArgsOut, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeBesselFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeBesselFilter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeBesselFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides an interface for the makeBesselFilter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void makeBesselFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("makeBesselFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeButterFilter()
    {
      return mcr.EvaluateFunction("makeButterFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeButterFilter(MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeButterFilter(MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeButterFilter(MWArray samplingFreq, MWArray order, MWArray 
                              cutOffFreq)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <param name="typeCode">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeButterFilter(MWArray samplingFreq, MWArray order, MWArray 
                              cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction("makeButterFilter", samplingFreq, order, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeButterFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeButterFilter(int numArgsOut, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeButterFilter(int numArgsOut, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeButterFilter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the makeButterFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="cutOffFreq">Input argument #3</param>
    /// <param name="typeCode">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeButterFilter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeButterFilter", samplingFreq, order, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeButterFilter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void makeButterFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("makeButterFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter()
    {
      return mcr.EvaluateFunction("makeCheby1Filter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter(MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter(MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby1Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple, MWArray cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction("makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the makeCheby1Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby1Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple, MWArray cutOffFreq, 
                                MWArray typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby1Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeCheby1Filter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void makeCheby1Filter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("makeCheby1Filter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter()
    {
      return mcr.EvaluateFunction("makeCheby2Filter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter(MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter(MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeCheby2Filter(MWArray samplingFreq, MWArray order, MWArray 
                              PassBandRipple, MWArray cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction("makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple, MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the makeCheby2Filter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="cutOffFreq">Input argument #4</param>
    /// <param name="typeCode">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeCheby2Filter(int numArgsOut, MWArray samplingFreq, MWArray 
                                order, MWArray PassBandRipple, MWArray cutOffFreq, 
                                MWArray typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeCheby2Filter", samplingFreq, order, PassBandRipple, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeCheby2Filter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void makeCheby2Filter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("makeCheby2Filter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter()
    {
      return mcr.EvaluateFunction("makeEllipFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq, MWArray order, MWArray 
                             PassBandRipple)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq, MWArray order, MWArray 
                             PassBandRipple, MWArray StopBandAttenuation)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq, MWArray order, MWArray 
                             PassBandRipple, MWArray StopBandAttenuation, MWArray 
                             cutOffFreq)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq);
    }


    /// <summary>
    /// Provides a single output, 6-input MWArrayinterface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <param name="typeCode">Input argument #6</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray makeEllipFilter(MWArray samplingFreq, MWArray order, MWArray 
                             PassBandRipple, MWArray StopBandAttenuation, MWArray 
                             cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction("makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq, MWArray order)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq, MWArray order, 
                               MWArray PassBandRipple)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq, MWArray order, 
                               MWArray PassBandRipple, MWArray StopBandAttenuation)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq, MWArray order, 
                               MWArray PassBandRipple, MWArray StopBandAttenuation, 
                               MWArray cutOffFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the makeEllipFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingFreq">Input argument #1</param>
    /// <param name="order">Input argument #2</param>
    /// <param name="PassBandRipple">Input argument #3</param>
    /// <param name="StopBandAttenuation">Input argument #4</param>
    /// <param name="cutOffFreq">Input argument #5</param>
    /// <param name="typeCode">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeEllipFilter(int numArgsOut, MWArray samplingFreq, MWArray order, 
                               MWArray PassBandRipple, MWArray StopBandAttenuation, 
                               MWArray cutOffFreq, MWArray typeCode)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeEllipFilter", samplingFreq, order, PassBandRipple, StopBandAttenuation, cutOffFreq, typeCode);
    }


    /// <summary>
    /// Provides an interface for the makeEllipFilter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void makeEllipFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("makeEllipFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void makeLines()
    {
      mcr.EvaluateFunction(0, "makeLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void makeLines(MWArray traceName)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    ///
    public void makeLines(MWArray traceName, MWArray colorName)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName, colorName);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    ///
    public void makeLines(MWArray traceName, MWArray colorName, MWArray lineWidth)
    {
      mcr.EvaluateFunction(0, "makeLines", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines(int numArgsOut, MWArray traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines(int numArgsOut, MWArray traceName, MWArray colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName, colorName);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeLines M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines(int numArgsOut, MWArray traceName, MWArray colorName, 
                         MWArray lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    ///
    public void makeLines2()
    {
      mcr.EvaluateFunction(0, "makeLines2", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    ///
    public void makeLines2(MWArray traceName)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    ///
    public void makeLines2(MWArray traceName, MWArray colorName)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName, colorName);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    ///
    public void makeLines2(MWArray traceName, MWArray colorName, MWArray lineWidth)
    {
      mcr.EvaluateFunction(0, "makeLines2", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines2(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines2(int numArgsOut, MWArray traceName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines2(int numArgsOut, MWArray traceName, MWArray colorName)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName, colorName);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the makeLines2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// zData=evalin('base','zData');
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="traceName">Input argument #1</param>
    /// <param name="colorName">Input argument #2</param>
    /// <param name="lineWidth">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLines2(int numArgsOut, MWArray traceName, MWArray colorName, 
                          MWArray lineWidth)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLines2", traceName, colorName, lineWidth);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the makeLinesTest M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void makeLinesTest()
    {
      mcr.EvaluateFunction(0, "makeLinesTest", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the makeLinesTest M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] makeLinesTest(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "makeLinesTest", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the Matlab_Setup_Listener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void Matlab_Setup_Listener()
    {
      mcr.EvaluateFunction(0, "Matlab Setup Listener", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the Matlab_Setup_Listener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] Matlab_Setup_Listener(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "Matlab Setup Listener", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlot()
    {
      return mcr.EvaluateFunction("matlabPlot", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlot(MWArray x)
    {
      return mcr.EvaluateFunction("matlabPlot", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlot(MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlot(MWArray x, MWArray y, MWArray figureName)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlot(MWArray x, MWArray y, MWArray figureName, MWArray 
                        parameterString)
    {
      return mcr.EvaluateFunction("matlabPlot", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlot(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlot(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlot(int numArgsOut, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlot(int numArgsOut, MWArray x, MWArray y, MWArray figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the matlabPlot M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlot(int numArgsOut, MWArray x, MWArray y, MWArray figureName, 
                          MWArray parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlot", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlot function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void matlabPlot(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("matlabPlot", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotNoJitter()
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotNoJitter(MWArray x)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotNoJitter(MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotNoJitter(MWArray x, MWArray y, MWArray figureName)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotNoJitter(MWArray x, MWArray y, MWArray figureName, MWArray 
                                parameterString)
    {
      return mcr.EvaluateFunction("matlabPlotNoJitter", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotNoJitter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotNoJitter(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotNoJitter(int numArgsOut, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotNoJitter(int numArgsOut, MWArray x, MWArray y, MWArray 
                                  figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the matlabPlotNoJitter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotNoJitter(int numArgsOut, MWArray x, MWArray y, MWArray 
                                  figureName, MWArray parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotNoJitter", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlotNoJitter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void matlabPlotNoJitter(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("matlabPlotNoJitter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotOld()
    {
      return mcr.EvaluateFunction("matlabPlotOld", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotOld(MWArray x)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotOld(MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotOld(MWArray x, MWArray y, MWArray figureName)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y, figureName);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the matlabPlotOld
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray matlabPlotOld(MWArray x, MWArray y, MWArray figureName, MWArray 
                           parameterString)
    {
      return mcr.EvaluateFunction("matlabPlotOld", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotOld(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotOld(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotOld(int numArgsOut, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotOld(int numArgsOut, MWArray x, MWArray y, MWArray 
                             figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y, figureName);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the matlabPlotOld M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <param name="parameterString">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] matlabPlotOld(int numArgsOut, MWArray x, MWArray y, MWArray 
                             figureName, MWArray parameterString)
    {
      return mcr.EvaluateFunction(numArgsOut, "matlabPlotOld", x, y, figureName, parameterString);
    }


    /// <summary>
    /// Provides an interface for the matlabPlotOld function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void matlabPlotOld(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("matlabPlotOld", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the MatlabSetupListener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void MatlabSetupListener()
    {
      mcr.EvaluateFunction(0, "MatlabSetupListener", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MatlabSetupListener
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MatlabSetupListener(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MatlabSetupListener", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the meanVariance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray meanVariance()
    {
      return mcr.EvaluateFunction("meanVariance", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the meanVariance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray meanVariance(MWArray inData)
    {
      return mcr.EvaluateFunction("meanVariance", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the meanVariance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray meanVariance(MWArray inData, MWArray windowLength)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the meanVariance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray meanVariance(MWArray inData, MWArray windowLength, MWArray 
                          overlapRatio)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength, overlapRatio);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the meanVariance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <param name="outputAxis">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray meanVariance(MWArray inData, MWArray windowLength, MWArray 
                          overlapRatio, MWArray outputAxis)
    {
      return mcr.EvaluateFunction("meanVariance", inData, windowLength, overlapRatio, outputAxis);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] meanVariance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] meanVariance(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] meanVariance(int numArgsOut, MWArray inData, MWArray windowLength)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] meanVariance(int numArgsOut, MWArray inData, MWArray windowLength, 
                            MWArray overlapRatio)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength, overlapRatio);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the meanVariance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowLength">Input argument #2</param>
    /// <param name="overlapRatio">Input argument #3</param>
    /// <param name="outputAxis">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] meanVariance(int numArgsOut, MWArray inData, MWArray windowLength, 
                            MWArray overlapRatio, MWArray outputAxis)
    {
      return mcr.EvaluateFunction(numArgsOut, "meanVariance", inData, windowLength, overlapRatio, outputAxis);
    }


    /// <summary>
    /// Provides an interface for the meanVariance function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// outValue = meanVariance(inData, windowLength, overlapRatio, outputAxis);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void meanVariance(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("meanVariance", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the medianFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray medianFilter()
    {
      return mcr.EvaluateFunction("medianFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the medianFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="vec">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray medianFilter(MWArray vec)
    {
      return mcr.EvaluateFunction("medianFilter", vec);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the medianFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="vec">Input argument #1</param>
    /// <param name="size">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray medianFilter(MWArray vec, MWArray size)
    {
      return mcr.EvaluateFunction("medianFilter", vec, size);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] medianFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vec">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] medianFilter(int numArgsOut, MWArray vec)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", vec);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the medianFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vec">Input argument #1</param>
    /// <param name="size">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] medianFilter(int numArgsOut, MWArray vec, MWArray size)
    {
      return mcr.EvaluateFunction(numArgsOut, "medianFilter", vec, size);
    }


    /// <summary>
    /// Provides an interface for the medianFilter function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Apply a median filter to vector VEC
    /// [NEWVEC] = APPLY_MEDIAN_FILTER(VEC)
    /// Replace each item with the median of itself and its two
    /// neighbors. For the first and last item, simply take the
    /// median of themselves and their only neighbor.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void medianFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("medianFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaBar()
    {
      return mcr.EvaluateFunction("metaBar", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaBar(MWArray titles)
    {
      return mcr.EvaluateFunction("metaBar", titles);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaBar(MWArray titles, MWArray xData)
    {
      return mcr.EvaluateFunction("metaBar", titles, xData);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaBar(MWArray titles, MWArray xData, MWArray yData)
    {
      return mcr.EvaluateFunction("metaBar", titles, xData, yData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaBar(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaBar(int numArgsOut, MWArray titles)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaBar(int numArgsOut, MWArray titles, MWArray xData)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles, xData);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the metaBar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="titles">Input argument #1</param>
    /// <param name="xData">Input argument #2</param>
    /// <param name="yData">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaBar(int numArgsOut, MWArray titles, MWArray xData, MWArray yData)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaBar", titles, xData, yData);
    }


    /// <summary>
    /// Provides an interface for the metaBar function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// generate mega plot
    /// figHandle = metaBar(titles, xData, yData)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void metaBar(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("metaBar", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the metaCorrEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaCorrEvents()
    {
      return mcr.EvaluateFunction("metaCorrEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the metaCorrEvents
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray metaCorrEvents(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("metaCorrEvents", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the metaCorrEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaCorrEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaCorrEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the metaCorrEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] metaCorrEvents(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "metaCorrEvents", varargin);
    }


    /// <summary>
    /// Provides an interface for the metaCorrEvents function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// calculate significance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void metaCorrEvents(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("metaCorrEvents", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLdiff()
    {
      return mcr.EvaluateFunction("MLdiff", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLdiff(MWArray x)
    {
      return mcr.EvaluateFunction("MLdiff", x);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLdiff(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLdiff", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MLdiff M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLdiff(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLdiff", x);
    }


    /// <summary>
    /// Provides an interface for the MLdiff function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MLdiff(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MLdiff", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLmedfilt1()
    {
      return mcr.EvaluateFunction("MLmedfilt1", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLmedfilt1(MWArray x)
    {
      return mcr.EvaluateFunction("MLmedfilt1", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="n">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLmedfilt1(MWArray x, MWArray n)
    {
      return mcr.EvaluateFunction("MLmedfilt1", x, n);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLmedfilt1(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLmedfilt1(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MLmedfilt1 M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="n">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLmedfilt1(int numArgsOut, MWArray x, MWArray n)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLmedfilt1", x, n);
    }


    /// <summary>
    /// Provides an interface for the MLmedfilt1 function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MLmedfilt1(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MLmedfilt1", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyfit()
    {
      return mcr.EvaluateFunction("MLpolyfit", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyfit(MWArray x)
    {
      return mcr.EvaluateFunction("MLpolyfit", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyfit(MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("MLpolyfit", x, y);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="n">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyfit(MWArray x, MWArray y, MWArray n)
    {
      return mcr.EvaluateFunction("MLpolyfit", x, y, n);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyfit(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyfit(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyfit(int numArgsOut, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x, y);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the MLpolyfit M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <param name="n">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyfit(int numArgsOut, MWArray x, MWArray y, MWArray n)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyfit", x, y, n);
    }


    /// <summary>
    /// Provides an interface for the MLpolyfit function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MLpolyfit(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MLpolyfit", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyval()
    {
      return mcr.EvaluateFunction("MLpolyval", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyval(MWArray p)
    {
      return mcr.EvaluateFunction("MLpolyval", p);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLpolyval(MWArray p, MWArray x)
    {
      return mcr.EvaluateFunction("MLpolyval", p, x);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyval(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyval(int numArgsOut, MWArray p)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", p);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MLpolyval M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLpolyval(int numArgsOut, MWArray p, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLpolyval", p, x);
    }


    /// <summary>
    /// Provides an interface for the MLpolyval function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MLpolyval(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MLpolyval", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MLsgolayfilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLsgolayfilt()
    {
      return mcr.EvaluateFunction("MLsgolayfilt", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MLsgolayfilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLsgolayfilt(MWArray x)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MLsgolayfilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLsgolayfilt(MWArray x, MWArray k)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x, k);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the MLsgolayfilt
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MLsgolayfilt(MWArray x, MWArray k, MWArray f)
    {
      return mcr.EvaluateFunction("MLsgolayfilt", x, k, f);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLsgolayfilt(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLsgolayfilt(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLsgolayfilt(int numArgsOut, MWArray x, MWArray k)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x, k);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the MLsgolayfilt M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="k">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MLsgolayfilt(int numArgsOut, MWArray x, MWArray k, MWArray f)
    {
      return mcr.EvaluateFunction(numArgsOut, "MLsgolayfilt", x, k, f);
    }


    /// <summary>
    /// Provides an interface for the MLsgolayfilt function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MLsgolayfilt(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MLsgolayfilt", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingAverage()
    {
      return mcr.EvaluateFunction("movingAverage", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingAverage(MWArray inData)
    {
      return mcr.EvaluateFunction("movingAverage", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the movingAverage
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingAverage(MWArray inData, MWArray windowSize)
    {
      return mcr.EvaluateFunction("movingAverage", inData, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingAverage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingAverage(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the movingAverage M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingAverage(int numArgsOut, MWArray inData, MWArray windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingAverage", inData, windowSize);
    }


    /// <summary>
    /// Provides an interface for the movingAverage function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void movingAverage(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("movingAverage", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingBlock()
    {
      return mcr.EvaluateFunction("movingBlock", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData_in1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingBlock(MWArray inData_in1)
    {
      return mcr.EvaluateFunction("movingBlock", inData_in1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="inData_in1">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray movingBlock(MWArray inData_in1, MWArray windowSize)
    {
      return mcr.EvaluateFunction("movingBlock", inData_in1, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingBlock(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData_in1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingBlock(int numArgsOut, MWArray inData_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", inData_in1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the movingBlock M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData_in1">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] movingBlock(int numArgsOut, MWArray inData_in1, MWArray windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "movingBlock", inData_in1, windowSize);
    }


    /// <summary>
    /// Provides an interface for the movingBlock function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use a boxcar filter of length windowSize points on inData
    /// filteredData = movingAverage(rawData, windowSize);
    /// defaults:
    /// windowSize = 10 points
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void movingBlock(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("movingBlock", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray msec2point()
    {
      return mcr.EvaluateFunction("msec2point", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray msec2point(MWArray inString)
    {
      return mcr.EvaluateFunction("msec2point", inString);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray msec2point(MWArray inString, MWArray pointsPerMsec)
    {
      return mcr.EvaluateFunction("msec2point", inString, pointsPerMsec);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <param name="firstTime">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray msec2point(MWArray inString, MWArray pointsPerMsec, MWArray firstTime)
    {
      return mcr.EvaluateFunction("msec2point", inString, pointsPerMsec, firstTime);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] msec2point(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] msec2point(int numArgsOut, MWArray inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] msec2point(int numArgsOut, MWArray inString, MWArray pointsPerMsec)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString, pointsPerMsec);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the msec2point M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <param name="pointsPerMsec">Input argument #2</param>
    /// <param name="firstTime">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] msec2point(int numArgsOut, MWArray inString, MWArray pointsPerMsec, 
                          MWArray firstTime)
    {
      return mcr.EvaluateFunction(numArgsOut, "msec2point", inString, pointsPerMsec, firstTime);
    }


    /// <summary>
    /// Provides an interface for the msec2point function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void msec2point(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("msec2point", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEO()
    {
      return mcr.EvaluateFunction("MTEO", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEO(MWArray inData)
    {
      return mcr.EvaluateFunction("MTEO", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEO(MWArray inData, MWArray kData)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEO(MWArray inData, MWArray kData, MWArray threshold)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData, threshold);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEO(MWArray inData, MWArray kData, MWArray threshold, MWArray windows)
    {
      return mcr.EvaluateFunction("MTEO", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEO(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEO(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEO(int numArgsOut, MWArray inData, MWArray kData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEO(int numArgsOut, MWArray inData, MWArray kData, MWArray 
                    threshold)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData, threshold);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the MTEO M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEO(int numArgsOut, MWArray inData, MWArray kData, MWArray 
                    threshold, MWArray windows)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEO", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides an interface for the MTEO function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MTEO(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MTEO", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEOBen()
    {
      return mcr.EvaluateFunction("MTEOBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEOBen(MWArray inData)
    {
      return mcr.EvaluateFunction("MTEOBen", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEOBen(MWArray inData, MWArray kData)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEOBen(MWArray inData, MWArray kData, MWArray threshold)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData, threshold);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray MTEOBen(MWArray inData, MWArray kData, MWArray threshold, MWArray 
                     windows)
    {
      return mcr.EvaluateFunction("MTEOBen", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEOBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEOBen(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEOBen(int numArgsOut, MWArray inData, MWArray kData)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEOBen(int numArgsOut, MWArray inData, MWArray kData, MWArray 
                       threshold)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData, threshold);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the MTEOBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="kData">Input argument #2</param>
    /// <param name="threshold">Input argument #3</param>
    /// <param name="windows">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] MTEOBen(int numArgsOut, MWArray inData, MWArray kData, MWArray 
                       threshold, MWArray windows)
    {
      return mcr.EvaluateFunction(numArgsOut, "MTEOBen", inData, kData, threshold, windows);
    }


    /// <summary>
    /// Provides an interface for the MTEOBen function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// after Choi and Kim, Electronics Letters, 38(12) 2002, 541-3 and
    /// Choi, Jung, and Kim, IEEE Transactions on Biomedical Engineering, 53(4), 2006,
    /// 738-746
    /// spikeLocations = MTEO(rawData, k-teo values, threshold, windows);
    /// filteredData = MTEO(rawData, k-teo values);
    /// for multiple windows (as rows) the output data is a column vector of
    /// number of spikes in each window
    /// defaults:
    /// k-teo values = 14;
    /// threshold = 0: 3 * gaussian estimate of noise maximum
    /// threshold &lt; 0: threshold * gaussian estimate of noise maximum
    /// threshold > 0: threshold
    /// windows is [1 length(rawData)];
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void MTEOBen(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("MTEOBen", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    ///
    public void newScale()
    {
      mcr.EvaluateFunction(0, "newScale", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="objectHandle">Input argument #1</param>
    ///
    public void newScale(MWArray objectHandle)
    {
      mcr.EvaluateFunction(0, "newScale", objectHandle);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="objectHandle">Input argument #1</param>
    /// <param name="eventInfo">Input argument #2</param>
    ///
    public void newScale(MWArray objectHandle, MWArray eventInfo)
    {
      mcr.EvaluateFunction(0, "newScale", objectHandle, eventInfo);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] newScale(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="objectHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] newScale(int numArgsOut, MWArray objectHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", objectHandle);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the newScale M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// update all axes
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="objectHandle">Input argument #1</param>
    /// <param name="eventInfo">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] newScale(int numArgsOut, MWArray objectHandle, MWArray eventInfo)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScale", objectHandle, eventInfo);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray newScope()
    {
      return mcr.EvaluateFunction("newScope", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray newScope(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("newScope", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] newScope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScope", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the newScope M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] newScope(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "newScope", varargin);
    }


    /// <summary>
    /// Provides an interface for the newScope function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// display data channels in a scrollable window
    /// newScope(yData, protocol)
    /// newScope(yData, protocol, figureHandle)
    /// newScope({yDataGroup1, yDataGroup2})
    /// newScope({yDataGroup1, yDataGroup2}, [xData], [channelNames], [figureHandle])
    /// where [] denote an optional arguement (order does not matter)
    /// Example:
    /// newScope({[tan(1.1:.01:11); cos(.1:.01:10)], [tan(.1:.01:10); cos(.1:.01:10)]},
    /// {'Dogs', 'Cats'});
    /// The reason that these scheme seems so odd is that it allows fewer copies
    /// of the data to be stored in the workspace so that you can work with
    /// larger data sets.  This is accomplished because Matlab cleverly holds
    /// onto a pointer to the copy of the input when there are subfunctions
    /// addressing the data instead of creating another copy.  Doubly cleverly,
    /// if the input data is cleared from its native location (probably the base
    /// workspace) then Matlab doesn't clear it from memory so that the function
    /// can still refer to it.  However, as soon as the last subfunction callback
    /// that uses the data is disconnected from the figure Matlab will delete the
    /// data set, allowing the user to clear the data copy at will be removing
    /// callbacks.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void newScope(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("newScope", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray normalizeMatrix()
    {
      return mcr.EvaluateFunction("normalizeMatrix", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="inMatrix">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray normalizeMatrix(MWArray inMatrix)
    {
      return mcr.EvaluateFunction("normalizeMatrix", inMatrix);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="inMatrix">Input argument #1</param>
    /// <param name="dim">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray normalizeMatrix(MWArray inMatrix, MWArray dim)
    {
      return mcr.EvaluateFunction("normalizeMatrix", inMatrix, dim);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] normalizeMatrix(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inMatrix">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] normalizeMatrix(int numArgsOut, MWArray inMatrix)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", inMatrix);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the normalizeMatrix
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inMatrix">Input argument #1</param>
    /// <param name="dim">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] normalizeMatrix(int numArgsOut, MWArray inMatrix, MWArray dim)
    {
      return mcr.EvaluateFunction(numArgsOut, "normalizeMatrix", inMatrix, dim);
    }


    /// <summary>
    /// Provides an interface for the normalizeMatrix function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// normalize a matrix along a given dimension
    /// dim = 0 does a global normalization
    /// outMatrix = normalizeMatrix(inMatrix, dim);
    /// defaults:
    /// dim = 2
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void normalizeMatrix(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("normalizeMatrix", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray notchFilter()
    {
      return mcr.EvaluateFunction("notchFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray notchFilter(MWArray inData)
    {
      return mcr.EvaluateFunction("notchFilter", inData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray notchFilter(MWArray inData, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction("notchFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="values">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray notchFilter(MWArray inData, MWArray samplingFreq, MWArray values)
    {
      return mcr.EvaluateFunction("notchFilter", inData, samplingFreq, values);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] notchFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] notchFilter(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] notchFilter(int numArgsOut, MWArray inData, MWArray samplingFreq)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData, samplingFreq);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the notchFilter M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="samplingFreq">Input argument #2</param>
    /// <param name="values">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] notchFilter(int numArgsOut, MWArray inData, MWArray samplingFreq, 
                           MWArray values)
    {
      return mcr.EvaluateFunction(numArgsOut, "notchFilter", inData, samplingFreq, values);
    }


    /// <summary>
    /// Provides an interface for the notchFilter function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// notch filters data
    /// filteredData = notchFilter(rawData, samplingFrequency, values);
    /// if values is nan(s) then the function will execute a gradient search of
    /// correlation around 60 Hz (and multiples thereof) to find maximum
    /// correlation in the input signal.
    /// defaults:
    /// samplingFrequency = 5000 Hz
    /// values = 60.023 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void notchFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("notchFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray oneSidedDeviation()
    {
      return mcr.EvaluateFunction("oneSidedDeviation", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray oneSidedDeviation(MWArray inData)
    {
      return mcr.EvaluateFunction("oneSidedDeviation", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] oneSidedDeviation(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "oneSidedDeviation", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the oneSidedDeviation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] oneSidedDeviation(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "oneSidedDeviation", inData);
    }


    /// <summary>
    /// Provides an interface for the oneSidedDeviation function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// use an outlier-insensitive deviation measure that assumes a mean of zero
    /// outValue = oneSidedDeviation(inData);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void oneSidedDeviation(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("oneSidedDeviation", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    ///
    public void overlayPSPs()
    {
      mcr.EvaluateFunction(0, "overlayPSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    ///
    public void overlayPSPs(MWArray inData)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    ///
    public void overlayPSPs(MWArray inData, MWArray timeWindow)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    ///
    public void overlayPSPs(MWArray inData, MWArray timeWindow, MWArray startTimes)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow, startTimes);
    }


    /// <summary>
    /// Provides a void output, 4-input MWArrayinterface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    ///
    public void overlayPSPs(MWArray inData, MWArray timeWindow, MWArray startTimes, 
                      MWArray timePerPoint)
    {
      mcr.EvaluateFunction(0, "overlayPSPs", inData, timeWindow, startTimes, timePerPoint);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] overlayPSPs(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] overlayPSPs(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] overlayPSPs(int numArgsOut, MWArray inData, MWArray timeWindow)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] overlayPSPs(int numArgsOut, MWArray inData, MWArray timeWindow, 
                           MWArray startTimes)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow, startTimes);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the overlayPSPs M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// display the PSPs for a given trace overlayed
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <param name="timeWindow">Input argument #2</param>
    /// <param name="startTimes">Input argument #3</param>
    /// <param name="timePerPoint">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] overlayPSPs(int numArgsOut, MWArray inData, MWArray timeWindow, 
                           MWArray startTimes, MWArray timePerPoint)
    {
      return mcr.EvaluateFunction(numArgsOut, "overlayPSPs", inData, timeWindow, startTimes, timePerPoint);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotAverageFreq()
    {
      return mcr.EvaluateFunction("plotAverageFreq", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotAverageFreq(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("plotAverageFreq", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotAverageFreq(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotAverageFreq", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the plotAverageFreq
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotAverageFreq(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotAverageFreq", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotAverageFreq function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void plotAverageFreq(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("plotAverageFreq", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotFreq()
    {
      return mcr.EvaluateFunction("plotFreq", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotFreq(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("plotFreq", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotFreq(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotFreq", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the plotFreq M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotFreq(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotFreq", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotFreq function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void plotFreq(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("plotFreq", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotHistogram()
    {
      return mcr.EvaluateFunction("plotHistogram", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotHistogram(MWArray inValues)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotHistogram(MWArray inValues, MWArray xAxisBins)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues, xAxisBins);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the plotHistogram
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotHistogram(MWArray inValues, MWArray xAxisBins, MWArray figureName)
    {
      return mcr.EvaluateFunction("plotHistogram", inValues, xAxisBins, figureName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotHistogram(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotHistogram(int numArgsOut, MWArray inValues)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotHistogram(int numArgsOut, MWArray inValues, MWArray xAxisBins)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues, xAxisBins);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the plotHistogram M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inValues">Input argument #1</param>
    /// <param name="xAxisBins">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotHistogram(int numArgsOut, MWArray inValues, MWArray xAxisBins, 
                             MWArray figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotHistogram", inValues, xAxisBins, figureName);
    }


    /// <summary>
    /// Provides an interface for the plotHistogram function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void plotHistogram(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("plotHistogram", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotPercentCorrelation()
    {
      return mcr.EvaluateFunction("plotPercentCorrelation", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray plotPercentCorrelation(params MWArray[] varargin)
    {
      return mcr.EvaluateFunction("plotPercentCorrelation", varargin);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotPercentCorrelation(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotPercentCorrelation", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the plotPercentCorrelation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 1
    /// through varargin.length</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] plotPercentCorrelation(int numArgsOut, params MWArray[] varargin)
    {
      return mcr.EvaluateFunction(numArgsOut, "plotPercentCorrelation", varargin);
    }


    /// <summary>
    /// Provides an interface for the plotPercentCorrelation function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// get handles to the event traces
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void plotPercentCorrelation(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                             argsIn)
    {
      mcr.EvaluateFunction("plotPercentCorrelation", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the prepForPrint
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray prepForPrint()
    {
      return mcr.EvaluateFunction("prepForPrint", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the prepForPrint
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray prepForPrint(MWArray currentAxis)
    {
      return mcr.EvaluateFunction("prepForPrint", currentAxis);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the prepForPrint
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray prepForPrint(MWArray currentAxis, MWArray yVal)
    {
      return mcr.EvaluateFunction("prepForPrint", currentAxis, yVal);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the prepForPrint
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray prepForPrint(MWArray currentAxis, MWArray yVal, params MWArray[] 
                          varargin)
    {
      MWArray[] args = {currentAxis, yVal};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction("prepForPrint", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] prepForPrint(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] prepForPrint(int numArgsOut, MWArray currentAxis)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", currentAxis);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] prepForPrint(int numArgsOut, MWArray currentAxis, MWArray yVal)
    {
      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", currentAxis, yVal);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the prepForPrint M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="currentAxis">Input argument #1</param>
    /// <param name="yVal">Input argument #2</param>
    /// <param name="varargin">Array of MWArrays representing the input arguments 3
    /// through varargin.length+2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] prepForPrint(int numArgsOut, MWArray currentAxis, MWArray yVal, 
                            params MWArray[] varargin)
    {
      MWArray[] args = {currentAxis, yVal};
      int nonVarargInputNum = args.Length;
      int varargInputNum = varargin.Length;
      int totalNumArgs = varargInputNum > 0 ? (nonVarargInputNum + varargInputNum) : nonVarargInputNum;
      Array newArr = Array.CreateInstance(typeof(MWArray), totalNumArgs);

      int idx = 0;

      for (idx = 0; idx < nonVarargInputNum; idx++)
        newArr.SetValue(args[idx],idx);

      if (varargInputNum > 0)
      {
        for (int i = 0; i < varargInputNum; i++)
        {
          newArr.SetValue(varargin[i], idx);
          idx++;
        }
      }

      return mcr.EvaluateFunction(numArgsOut, "prepForPrint", (MWArray[])newArr );
    }


    /// <summary>
    /// Provides an interface for the prepForPrint function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Hides axes and places a scale bar with y-units set by yVal (a character
    /// array).  Possible options include:
    /// 'xOnly'              -display only the x scale
    /// 'yOnly',             -display only the y scale
    /// 'openRight'          -scale bars are open to the right
    /// 'openBottom'         -scale bars are open to the bottom
    /// 'location', [x y]    -normalized distance from bottom left corner
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void prepForPrint(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("prepForPrint", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    ///
    public void printWithAxes()
    {
      mcr.EvaluateFunction(0, "printWithAxes", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void printWithAxes(MWArray figure)
    {
      mcr.EvaluateFunction(0, "printWithAxes", figure);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] printWithAxes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithAxes", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the printWithAxes M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] printWithAxes(int numArgsOut, MWArray figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithAxes", figure);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    ///
    public void printWithScaleBars()
    {
      mcr.EvaluateFunction(0, "printWithScaleBars", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="figure">Input argument #1</param>
    ///
    public void printWithScaleBars(MWArray figure)
    {
      mcr.EvaluateFunction(0, "printWithScaleBars", figure);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] printWithScaleBars(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithScaleBars", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the printWithScaleBars
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// function for printing a newScope
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figure">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] printWithScaleBars(int numArgsOut, MWArray figure)
    {
      return mcr.EvaluateFunction(numArgsOut, "printWithScaleBars", figure);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBen()
    {
      return mcr.EvaluateFunction("readBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBen(MWArray filename)
    {
      return mcr.EvaluateFunction("readBen", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBen(MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction("readBen", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBen(int numArgsOut, MWArray filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", filename);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the readBen M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBen(int numArgsOut, MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBen", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBen function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Updated for modern .dat files 27 Jan 2012 BWS
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void readBen(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("readBen", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenNewStyle()
    {
      return mcr.EvaluateFunction("readBenNewStyle", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenNewStyle(MWArray filename)
    {
      return mcr.EvaluateFunction("readBenNewStyle", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenNewStyle(MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction("readBenNewStyle", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenNewStyle(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenNewStyle(int numArgsOut, MWArray filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", filename);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the readBenNewStyle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenNewStyle(int numArgsOut, MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenNewStyle", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBenNewStyle function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// import IV trace info
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void readBenNewStyle(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("readBenNewStyle", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenOld2()
    {
      return mcr.EvaluateFunction("readBenOld2", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenOld2(MWArray filename)
    {
      return mcr.EvaluateFunction("readBenOld2", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readBenOld2(MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction("readBenOld2", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenOld2(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenOld2(int numArgsOut, MWArray filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", filename);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the readBenOld2 M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readBenOld2(int numArgsOut, MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readBenOld2", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readBenOld2 function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// read header to determine number of traces, etc
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void readBenOld2(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("readBenOld2", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readTrace()
    {
      return mcr.EvaluateFunction("readTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readTrace(MWArray filename)
    {
      return mcr.EvaluateFunction("readTrace", filename);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readTrace(MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction("readTrace", filename, infoOnly);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readTrace(int numArgsOut, MWArray filename)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", filename);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the readTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="filename">Input argument #1</param>
    /// <param name="infoOnly">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readTrace(int numArgsOut, MWArray filename, MWArray infoOnly)
    {
      return mcr.EvaluateFunction(numArgsOut, "readTrace", filename, infoOnly);
    }


    /// <summary>
    /// Provides an interface for the readTrace function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// reads data traces generated by the data acquisition program
    /// zData = readTrace(fileName);
    /// protocol = readTrace(fileName, 1);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void readTrace(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("readTrace", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the readVBString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readVBString()
    {
      return mcr.EvaluateFunction("readVBString", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the readVBString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="fid">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray readVBString(MWArray fid)
    {
      return mcr.EvaluateFunction("readVBString", fid);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readVBString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "readVBString", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the readVBString M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="fid">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] readVBString(int numArgsOut, MWArray fid)
    {
      return mcr.EvaluateFunction(numArgsOut, "readVBString", fid);
    }


    /// <summary>
    /// Provides an interface for the readVBString function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// this function takes a handle to an open file and reads a VB encoded
    /// string.  It assumes the file position is correct
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void readVBString(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("readVBString", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the refreshAllScopes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void refreshAllScopes()
    {
      mcr.EvaluateFunction(0, "refreshAllScopes", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the refreshAllScopes
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] refreshAllScopes(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "refreshAllScopes", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray removeTrace()
    {
      return mcr.EvaluateFunction("removeTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray removeTrace(MWArray channelName)
    {
      return mcr.EvaluateFunction("removeTrace", channelName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] removeTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "removeTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the removeTrace M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="channelName">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] removeTrace(int numArgsOut, MWArray channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "removeTrace", channelName);
    }


    /// <summary>
    /// Provides an interface for the removeTrace function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void removeTrace(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("removeTrace", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the replaceTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray replaceTrace()
    {
      return mcr.EvaluateFunction("replaceTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the replaceTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray replaceTrace(MWArray newData)
    {
      return mcr.EvaluateFunction("replaceTrace", newData);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the replaceTrace
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray replaceTrace(MWArray newData, MWArray channelName)
    {
      return mcr.EvaluateFunction("replaceTrace", newData, channelName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] replaceTrace(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] replaceTrace(int numArgsOut, MWArray newData)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", newData);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the replaceTrace M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="newData">Input argument #1</param>
    /// <param name="channelName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] replaceTrace(int numArgsOut, MWArray newData, MWArray channelName)
    {
      return mcr.EvaluateFunction(numArgsOut, "replaceTrace", newData, channelName);
    }


    /// <summary>
    /// Provides an interface for the replaceTrace function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// error checking
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void replaceTrace(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("replaceTrace", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the restartSystem M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this should run when caught error is found
    /// </remarks>
    ///
    public void restartSystem()
    {
      mcr.EvaluateFunction(0, "restartSystem", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the restartSystem M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// this should run when caught error is found
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] restartSystem(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "restartSystem", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray runGeneralFilter()
    {
      return mcr.EvaluateFunction("runGeneralFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray runGeneralFilter(MWArray inData)
    {
      return mcr.EvaluateFunction("runGeneralFilter", inData);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] runGeneralFilter(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "runGeneralFilter", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the runGeneralFilter
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inData">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] runGeneralFilter(int numArgsOut, MWArray inData)
    {
      return mcr.EvaluateFunction(numArgsOut, "runGeneralFilter", inData);
    }


    /// <summary>
    /// Provides an interface for the runGeneralFilter function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void runGeneralFilter(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("runGeneralFilter", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile()
    {
      return mcr.EvaluateFunction("SaveAsMatFile", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile(MWArray inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SaveAsMatFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newFileName">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile(MWArray inArray, MWArray newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile", inArray, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SaveAsMatFile M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newFileName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile(int numArgsOut, MWArray inArray, MWArray newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile", inArray, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SaveAsMatFile(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("SaveAsMatFile", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile2Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile2Vectors(MWArray inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile2Vectors(MWArray inArray, MWArray inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="newFileName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile2Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile2Vectors", inArray, inArray2, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile2Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile2Vectors(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile2Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the SaveAsMatFile2Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="newFileName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile2Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile2Vectors", inArray, inArray2, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile2Vectors function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SaveAsMatFile2Vectors(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                            argsIn)
    {
      mcr.EvaluateFunction("SaveAsMatFile2Vectors", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3Vectors(MWArray inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3Vectors(MWArray inArray, MWArray inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   inArray3, MWArray newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3Vectors", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3Vectors(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the SaveAsMatFile3Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray inArray3, MWArray newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3Vectors", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile3Vectors function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SaveAsMatFile3Vectors(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                            argsIn)
    {
      mcr.EvaluateFunction("SaveAsMatFile3Vectors", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique()
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique(MWArray inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique(MWArray inArray, MWArray inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique(MWArray inArray, MWArray inArray2, MWArray 
                                         inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique(MWArray inArray, MWArray inArray2, MWArray 
                                         inArray3, MWArray newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <param name="newVarName">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile3VectorsUnique(MWArray inArray, MWArray inArray2, MWArray 
                                         inArray3, MWArray newFileName, MWArray 
                                         newVarName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName, newVarName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut, MWArray inArray, MWArray 
                                           inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut, MWArray inArray, MWArray 
                                           inArray2, MWArray inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut, MWArray inArray, MWArray 
                                           inArray2, MWArray inArray3, MWArray 
                                           newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the
    /// SaveAsMatFile3VectorsUnique M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="newFileName">Input argument #4</param>
    /// <param name="newVarName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile3VectorsUnique(int numArgsOut, MWArray inArray, MWArray 
                                           inArray2, MWArray inArray3, MWArray 
                                           newFileName, MWArray newVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile3VectorsUnique", inArray, inArray2, inArray3, newFileName, newVarName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile3VectorsUnique function in which the
    /// input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SaveAsMatFile3VectorsUnique(int numArgsOut, ref MWArray[] argsOut, 
                                  MWArray[] argsIn)
    {
      mcr.EvaluateFunction("SaveAsMatFile3VectorsUnique", numArgsOut, ref argsOut, 
                                  argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors()
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors(MWArray inArray)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors(MWArray inArray, MWArray inArray2)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   inArray3)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   inArray3, MWArray inArray4)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <param name="newFileName">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SaveAsMatFile4Vectors(MWArray inArray, MWArray inArray2, MWArray 
                                   inArray3, MWArray inArray4, MWArray newFileName)
    {
      return mcr.EvaluateFunction("SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4, newFileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray inArray3)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray inArray3, MWArray inArray4)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the SaveAsMatFile4Vectors
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="inArray2">Input argument #2</param>
    /// <param name="inArray3">Input argument #3</param>
    /// <param name="inArray4">Input argument #4</param>
    /// <param name="newFileName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SaveAsMatFile4Vectors(int numArgsOut, MWArray inArray, MWArray 
                                     inArray2, MWArray inArray3, MWArray inArray4, 
                                     MWArray newFileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SaveAsMatFile4Vectors", inArray, inArray2, inArray3, inArray4, newFileName);
    }


    /// <summary>
    /// Provides an interface for the SaveAsMatFile4Vectors function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SaveAsMatFile4Vectors(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                            argsIn)
    {
      mcr.EvaluateFunction("SaveAsMatFile4Vectors", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray sec2time()
    {
      return mcr.EvaluateFunction("sec2time", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numSecs">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray sec2time(MWArray numSecs)
    {
      return mcr.EvaluateFunction("sec2time", numSecs);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sec2time(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sec2time", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the sec2time M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="numSecs">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sec2time(int numArgsOut, MWArray numSecs)
    {
      return mcr.EvaluateFunction(numArgsOut, "sec2time", numSecs);
    }


    /// <summary>
    /// Provides an interface for the sec2time function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// convert seconds to hh:mm:ss.s format
    /// timeFormat = sec2time(numSecs);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void sec2time(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("sec2time", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendFilenamesToScope()
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScope", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendFilenamesToScope(MWArray commaList)
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScope", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendFilenamesToScope(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScope", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the sendFilenamesToScope
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendFilenamesToScope(int numArgsOut, MWArray commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScope", commaList);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendFilenamesToScopeNoRefresh()
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScopeNoRefresh", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendFilenamesToScopeNoRefresh(MWArray commaList)
    {
      mcr.EvaluateFunction(0, "sendFilenamesToScopeNoRefresh", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendFilenamesToScopeNoRefresh(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScopeNoRefresh", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the
    /// sendFilenamesToScopeNoRefresh M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendFilenamesToScopeNoRefresh(int numArgsOut, MWArray commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendFilenamesToScopeNoRefresh", commaList);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void sendMessage()
    {
      mcr.EvaluateFunction(0, "sendMessage", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="message">Input argument #1</param>
    ///
    public void sendMessage(MWArray message)
    {
      mcr.EvaluateFunction(0, "sendMessage", message);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendMessage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendMessage", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the sendMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="message">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendMessage(int numArgsOut, MWArray message)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendMessage", message);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    ///
    public void sendText()
    {
      mcr.EvaluateFunction(0, "sendText", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="commaList">Input argument #1</param>
    ///
    public void sendText(MWArray commaList)
    {
      mcr.EvaluateFunction(0, "sendText", commaList);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendText(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendText", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the sendText M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// add files
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="commaList">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sendText(int numArgsOut, MWArray commaList)
    {
      return mcr.EvaluateFunction(numArgsOut, "sendText", commaList);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SendToMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SendToMatlab()
    {
      return mcr.EvaluateFunction("SendToMatlab", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SendToMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SendToMatlab(MWArray inArray)
    {
      return mcr.EvaluateFunction("SendToMatlab", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SendToMatlab
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newVarName">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SendToMatlab(MWArray inArray, MWArray newVarName)
    {
      return mcr.EvaluateFunction("SendToMatlab", inArray, newVarName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SendToMatlab(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SendToMatlab(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SendToMatlab M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="newVarName">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SendToMatlab(int numArgsOut, MWArray inArray, MWArray newVarName)
    {
      return mcr.EvaluateFunction(numArgsOut, "SendToMatlab", inArray, newVarName);
    }


    /// <summary>
    /// Provides an interface for the SendToMatlab function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SendToMatlab(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("SendToMatlab", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void setAxisLabels()
    {
      mcr.EvaluateFunction(0, "setAxisLabels", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void setAxisLabels(MWArray axisHandle)
    {
      mcr.EvaluateFunction(0, "setAxisLabels", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setAxisLabels(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "setAxisLabels", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the setAxisLabels M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setAxisLabels(int numArgsOut, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "setAxisLabels", axisHandle);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray sfigure()
    {
      return mcr.EvaluateFunction("sfigure", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="h_in1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray sfigure(MWArray h_in1)
    {
      return mcr.EvaluateFunction("sfigure", h_in1);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sfigure(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "sfigure", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the sfigure M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="h_in1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] sfigure(int numArgsOut, MWArray h_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "sfigure", h_in1);
    }


    /// <summary>
    /// Provides an interface for the sfigure function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// SFIGURE  Create figure window (minus annoying focus-theft).
    /// Usage is identical to figure.
    /// Daniel Eaton, 2005
    /// See also figure
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void sfigure(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("sfigure", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SGfilterBen()
    {
      return mcr.EvaluateFunction("SGfilterBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SGfilterBen(MWArray InVector)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SGfilterBen(MWArray InVector, MWArray PolyOrder)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray SGfilterBen(MWArray InVector, MWArray PolyOrder, MWArray FrameSize)
    {
      return mcr.EvaluateFunction("SGfilterBen", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SGfilterBen(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SGfilterBen(int numArgsOut, MWArray InVector)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SGfilterBen(int numArgsOut, MWArray InVector, MWArray PolyOrder)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector, PolyOrder);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the SGfilterBen M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="InVector">Input argument #1</param>
    /// <param name="PolyOrder">Input argument #2</param>
    /// <param name="FrameSize">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] SGfilterBen(int numArgsOut, MWArray InVector, MWArray PolyOrder, 
                           MWArray FrameSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "SGfilterBen", InVector, PolyOrder, FrameSize);
    }


    /// <summary>
    /// Provides an interface for the SGfilterBen function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void SGfilterBen(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("SGfilterBen", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    ///
    public void showEvents()
    {
      mcr.EvaluateFunction(0, "showEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void showEvents(MWArray axisHandle)
    {
      mcr.EvaluateFunction(0, "showEvents", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showEvents(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showEvents", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the showEvents M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show the events for a given axis along the top of the axis
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showEvents(int numArgsOut, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showEvents", axisHandle);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray showFFT()
    {
      return mcr.EvaluateFunction("showFFT", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray showFFT(MWArray dataIn)
    {
      return mcr.EvaluateFunction("showFFT", dataIn);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray showFFT(MWArray dataIn, MWArray samplingRate)
    {
      return mcr.EvaluateFunction("showFFT", dataIn, samplingRate);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray showFFT(MWArray dataIn, MWArray samplingRate, MWArray figureName)
    {
      return mcr.EvaluateFunction("showFFT", dataIn, samplingRate, figureName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFFT(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFFT(int numArgsOut, MWArray dataIn)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFFT(int numArgsOut, MWArray dataIn, MWArray samplingRate)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn, samplingRate);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the showFFT M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="dataIn">Input argument #1</param>
    /// <param name="samplingRate">Input argument #2</param>
    /// <param name="figureName">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFFT(int numArgsOut, MWArray dataIn, MWArray samplingRate, 
                       MWArray figureName)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFFT", dataIn, samplingRate, figureName);
    }


    /// <summary>
    /// Provides an interface for the showFFT function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// displays power spectrum of data
    /// coefficients = showFFT(data, samplingFreq in Hz);
    /// defaults:
    /// samplingFreq = 5000 Hz
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void showFFT(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("showFFT", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    ///
    public void showFrameMarker()
    {
      mcr.EvaluateFunction(0, "showFrameMarker", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="axisHandle">Input argument #1</param>
    ///
    public void showFrameMarker(MWArray axisHandle)
    {
      mcr.EvaluateFunction(0, "showFrameMarker", axisHandle);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFrameMarker(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFrameMarker", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the showFrameMarker
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// deal with frame marker if present
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="axisHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showFrameMarker(int numArgsOut, MWArray axisHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showFrameMarker", axisHandle);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    ///
    public void showStims()
    {
      mcr.EvaluateFunction(0, "showStims", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    ///
    public void showStims(MWArray figHandle)
    {
      mcr.EvaluateFunction(0, "showStims", figHandle);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="figHandle">Input argument #1</param>
    /// <param name="showLegend">Input argument #2</param>
    ///
    public void showStims(MWArray figHandle, MWArray showLegend)
    {
      mcr.EvaluateFunction(0, "showStims", figHandle, showLegend);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showStims(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showStims(int numArgsOut, MWArray figHandle)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", figHandle);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the showStims M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// show TTL stimuli if they are blanked
    /// modified by BWS on 12/8/08
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="figHandle">Input argument #1</param>
    /// <param name="showLegend">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] showStims(int numArgsOut, MWArray figHandle, MWArray showLegend)
    {
      return mcr.EvaluateFunction(numArgsOut, "showStims", figHandle, showLegend);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the startInterprocess
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void startInterprocess()
    {
      mcr.EvaluateFunction(0, "startInterprocess", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the startInterprocess
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] startInterprocess(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "startInterprocess", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the testDrawLine M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testDrawLine()
    {
      mcr.EvaluateFunction(0, "testDrawLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the testDrawLine M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testDrawLine(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testDrawLine", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the testMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testMessage()
    {
      mcr.EvaluateFunction(0, "testMessage", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the testMessage M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testMessage(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessage", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void testMessageString()
    {
      mcr.EvaluateFunction(0, "testMessageString", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inString">Input argument #1</param>
    ///
    public void testMessageString(MWArray inString)
    {
      mcr.EvaluateFunction(0, "testMessageString", inString);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testMessageString(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessageString", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the testMessageString
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inString">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testMessageString(int numArgsOut, MWArray inString)
    {
      return mcr.EvaluateFunction(numArgsOut, "testMessageString", inString);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray timeControl()
    {
      return mcr.EvaluateFunction("timeControl", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="right">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray timeControl(MWArray right)
    {
      return mcr.EvaluateFunction("timeControl", right);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="right">Input argument #1</param>
    /// <param name="bottom">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray timeControl(MWArray right, MWArray bottom)
    {
      return mcr.EvaluateFunction("timeControl", right, bottom);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] timeControl(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="right">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] timeControl(int numArgsOut, MWArray right)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", right);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the timeControl M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="right">Input argument #1</param>
    /// <param name="bottom">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] timeControl(int numArgsOut, MWArray right, MWArray bottom)
    {
      return mcr.EvaluateFunction(numArgsOut, "timeControl", right, bottom);
    }


    /// <summary>
    /// Provides an interface for the timeControl function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void timeControl(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("timeControl", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray VBmedian()
    {
      return mcr.EvaluateFunction("VBmedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray VBmedian(MWArray inArray)
    {
      return mcr.EvaluateFunction("VBmedian", inArray);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] VBmedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the VBmedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] VBmedian(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmedian", inArray);
    }


    /// <summary>
    /// Provides an interface for the VBmedian function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void VBmedian(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("VBmedian", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray VBmovingMedian()
    {
      return mcr.EvaluateFunction("VBmovingMedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray VBmovingMedian(MWArray inArray)
    {
      return mcr.EvaluateFunction("VBmovingMedian", inArray);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the VBmovingMedian
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray VBmovingMedian(MWArray inArray, MWArray windowSize)
    {
      return mcr.EvaluateFunction("VBmovingMedian", inArray, windowSize);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] VBmovingMedian(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] VBmovingMedian(int numArgsOut, MWArray inArray)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", inArray);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the VBmovingMedian M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="inArray">Input argument #1</param>
    /// <param name="windowSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] VBmovingMedian(int numArgsOut, MWArray inArray, MWArray windowSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "VBmovingMedian", inArray, windowSize);
    }


    /// <summary>
    /// Provides an interface for the VBmovingMedian function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void VBmovingMedian(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("VBmovingMedian", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the wakeUp M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    ///
    public void wakeUp()
    {
      mcr.EvaluateFunction(0, "wakeUp", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the wakeUp M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] wakeUp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "wakeUp", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the whichChannel
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray whichChannel()
    {
      return mcr.EvaluateFunction("whichChannel", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the whichChannel
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray whichChannel(MWArray protocol)
    {
      return mcr.EvaluateFunction("whichChannel", protocol);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the whichChannel
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray whichChannel(MWArray protocol, MWArray ampNum)
    {
      return mcr.EvaluateFunction("whichChannel", protocol, ampNum);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the whichChannel
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <param name="channelType">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray whichChannel(MWArray protocol, MWArray ampNum, MWArray channelType)
    {
      return mcr.EvaluateFunction("whichChannel", protocol, ampNum, channelType);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whichChannel(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whichChannel(int numArgsOut, MWArray protocol)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whichChannel(int numArgsOut, MWArray protocol, MWArray ampNum)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol, ampNum);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the whichChannel M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="protocol">Input argument #1</param>
    /// <param name="ampNum">Input argument #2</param>
    /// <param name="channelType">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whichChannel(int numArgsOut, MWArray protocol, MWArray ampNum, 
                            MWArray channelType)
    {
      return mcr.EvaluateFunction(numArgsOut, "whichChannel", protocol, ampNum, channelType);
    }


    /// <summary>
    /// Provides an interface for the whichChannel function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// determine which channel a given amp is using
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void whichChannel(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("whichChannel", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    ///
    public void whiteNoiseFile()
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    ///
    public void whiteNoiseFile(MWArray samplingRate)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    ///
    public void whiteNoiseFile(MWArray samplingRate, MWArray duration)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    ///
    public void whiteNoiseFile(MWArray samplingRate, MWArray duration, MWArray peakToPeak)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak);
    }


    /// <summary>
    /// Provides a void output, 4-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    ///
    public void whiteNoiseFile(MWArray samplingRate, MWArray duration, MWArray 
                         peakToPeak, MWArray cutoff)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff);
    }


    /// <summary>
    /// Provides a void output, 5-input MWArrayinterface to the whiteNoiseFile
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <param name="fileName">Input argument #5</param>
    ///
    public void whiteNoiseFile(MWArray samplingRate, MWArray duration, MWArray 
                         peakToPeak, MWArray cutoff, MWArray fileName)
    {
      mcr.EvaluateFunction(0, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff, fileName);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut, MWArray samplingRate)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut, MWArray samplingRate, MWArray 
                              duration)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut, MWArray samplingRate, MWArray 
                              duration, MWArray peakToPeak)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut, MWArray samplingRate, MWArray 
                              duration, MWArray peakToPeak, MWArray cutoff)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the whiteNoiseFile M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// whiteNoiseFile(5000, 10, 1500, [100 1000], 'R:\whiteNoise.txt');
    /// sampling rate in Hz
    /// duration in seconds
    /// peakToPeak in pA before low pass filtering
    /// cutoff is two element cutoff [passStart blockStart] 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samplingRate">Input argument #1</param>
    /// <param name="duration">Input argument #2</param>
    /// <param name="peakToPeak">Input argument #3</param>
    /// <param name="cutoff">Input argument #4</param>
    /// <param name="fileName">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] whiteNoiseFile(int numArgsOut, MWArray samplingRate, MWArray 
                              duration, MWArray peakToPeak, MWArray cutoff, MWArray 
                              fileName)
    {
      return mcr.EvaluateFunction(numArgsOut, "whiteNoiseFile", samplingRate, duration, peakToPeak, cutoff, fileName);
    }



    /// <summary>
    /// This method will cause a MATLAB figure window to behave as a modal dialog box.
    /// The method will not return until all the figure windows associated with this
    /// component have been closed.
    /// </summary>
    /// <remarks>
    /// An application should only call this method when required to keep the
    /// MATLAB figure window from disappearing.  Other techniques, such as calling
    /// Console.ReadLine() from the application should be considered where
    /// possible.</remarks>
    ///
    public void WaitForFiguresToDie()
    {
      mcr.WaitForFiguresToDie();
    }



    #endregion Methods

    #region Class Members

    private static MWMCR mcr= null;

    private bool disposed= false;

    #endregion Class Members
  }
}
